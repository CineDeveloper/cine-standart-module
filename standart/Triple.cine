type Triple(first, second, third)
    first first
    second second
    third third

rules
    1 = type == Triple(_, _, _) & type[0] > Binary & type[1] > Binary & type[2] > Binary
    join 1 Binary
    2 = type == Triple(_, _, _) & type[0] > Equal & type[1] > Equal & type[2] > Equal
    join 2 Equal
    3 = type == Triple(_, _, _) & type[0] > StringWriter & type[1] > StringWriter & type[2] > StringWriter
    join 3 StringWriter
    4 = type == Triple(_, _, _) & type[0] > Hashed & type[1] > Hashed & type[2] > Hashed
    join 4 Hashed
    5 = type == Triple(_, _, _) & type[0] > Bits & type[1] > Bits & type[2] > Bits
    join 5 Bits

proc addEq(:data BinaryData, triple Triple(_, _, _))
    rules
        final = triple > Binary
    data += triple.first
    data += triple.second
    data += triple.third

func and(a Triple(_, _, _), b a) a
    attributes
        alwaysInline
    rules
        final = a > Bits
    result:first = a.first & b.first
    result:second = a.second & b.second
    result:third = a.third & b.third

func create(tripleType Triple(_, _, _), first tripleType[0], second tripleType[1], third tripleType[2]) tripleType
    attributes
        alwaysInline
    result:first = first
    result:second = second
    result:third = third

func equal(a Triple(_, _, _), b a) Bool
    attributes
        alwaysInline
    rules
        final = a > Equal
    result = a.first == b.first && a.second == b.second && a.third == b.third

func getFromBinaryData(triple Triple(_, _, _), data BinaryData, :position UInt64) triple
    rules
        final = triple > Binary
    result:first = #triple[0].getFromBinaryData(data, position)
    result:second = #triple[1].getFromBinaryData(data, position)
    result:third = #triple[2].getFromBinaryData(data, position)

func getHash(triple Triple(_, _, _)) UInt64
    attributes
        alwaysInline
    rules
        final = triple > Hashed
    result = triple.first.getHash()
    result += result << 10
    result ^= result >> 6
    result += getStaticRandomNumber()
    result += result << 10
    result ^= result >> 6
    result += triple.second.getHash()
    result += result << 10
    result ^= result >> 6
    result += triple.third.getHash()
    result += result << 10
    result ^= result >> 6
    result += result << 3
    result ^= result >> 11
    result += result << 15

func getHashSize(triple Triple(_, _, _)) UInt8
    attributes
        alwaysInline
    rules
        final = triple > Hashed
    result = 8.convertTo(UInt8)

func not(triple Triple(_, _, _)) triple
    attributes
        alwaysInline
    rules
        final = triple > Bits
    result:first = triple.first.not()
    result:second = triple.second.not()
    result:third = triple.third.not()

func or(a Triple(_, _, _), b a) a
    attributes
        alwaysInline
    rules
        final = a > Bits
    result:first = a.first | b.first
    result:second = a.second | b.second
    result:third = a.third | b.third

func shl(triple Triple(_, _, _), shifts > BasicUnsignedInteger) triple
    attributes
        alwaysInline
    rules
        final = triple > Bits
    result:first = triple.first << shifts
    result:second = triple.second << shifts
    result:third = triple.third << shifts

func shr(triple Triple(_, _, _), shifts > BasicUnsignedInteger) triple
    attributes
        alwaysInline
    rules
        final = triple > Bits
    result:first = triple.first >> shifts
    result:second = triple.second >> shifts
    result:third = triple.third >> shifts

func toString(triple Triple(_, _, _)) [UInt8]
    rules
        final = triple > StringWriter
    result = "(".join({
        triple.first.toString(), ", ",
        triple.second.toString(), ", " ,
        triple.third.toString(), ")")
    }

func xor(a Triple(_, _, _), b a) a
    attributes
        alwaysInline
    rules
        final = a > Bits
    result:first = a.first ^ b.first
    result:second = a.second ^ b.second
    result:third = a.third ^ b.third
