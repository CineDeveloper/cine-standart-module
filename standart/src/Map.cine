type Map(key, item)
    private_keysAndItems [Box(Pair(key, item))]
    private_trees [MapTreeNode]
    private_numberOfHiddenItems UInt16

proc add(:map Map(_, _), key map[0], item map[1])
    rules
        final = key > Hashed & key > Equal
    map += Pair(key, item).create(key, item)

proc addEq(:map Map(_, _), keyAndItem Pair(map[0], map[1]))
    rules
        final = map[0] > Hashed & map[0] > Equal
    if !map.init?()
        then map = #map.init()
    key .= keyAndItem.first
    keyHash := key.getSmallHash()
    firstNodeOfTreeIndex := 0
    currentNodeIndex := 0
    countOfLoops .= #map[0].getSmallHashSize() * 2.convertTo(UInt8)
    firstHash .= keyHash
    itemIndex := 0
    for
        for loopID := UInt8; loopID < countOfLoops; loopID++
            partOfKeyHash .= (keyHash & 15.convertTo(UInt32)).convertTo(UInt8)
            keyHash >>= 4
            fullCurrentIndex .= firstNodeOfTreeIndex + currentNodeIndex
            nextNodeIndex .= map.private_trees[fullCurrentIndex][partOfKeyHash]
            mif
                nextNodeIndex == 0
                    newNodeIndex .= map.private_trees.getLength() - firstNodeOfTreeIndex
                    currentNode := map.private_trees[fullCurrentIndex]
                    currentNode:setItem(partOfKeyHash, newNodeIndex)
                    map:private_trees:setItem(fullCurrentIndex, currentNode)
                    map:private_trees += MapTreeNode
                    if newNodeIndex == 16777215
                        then
                            firstNodeOfTreeIndex += 16777215
                            currentNodeIndex = 0
                            keyHash = firstHash
                            continue first
                        else currentNodeIndex = newNodeIndex
                nextNodeIndex == 16777215
                    firstNodeOfTreeIndex += 16777215
                    currentNodeIndex = 0
                    keyHash = firstHash
                    continue first
                default
                    currentNodeIndex = nextNodeIndex
        for
            fullCurrentIndex .= firstNodeOfTreeIndex + currentNodeIndex
            if itemIndex = map.private_trees[fullCurrentIndex].getItemIndex(); itemIndex == 0
                then
                    itemIndex = map.private_keysAndItems.getLength()
                    map:private_keysAndItems += Box(keyAndItem)
                    break
            if resultKeyAndItem .= map.private_keysAndItems[itemIndex]; resultKeyAndItem.item?() && resultKeyAndItem[].first == key
                then break
            nextNodeIndex .= map.private_trees[fullCurrentIndex].getNodeIndexWithOtherItemIndex()
            mif
                nextNodeIndex == 0
                    newNodeIndex .= map.private_trees.getLength() - firstNodeOfTreeIndex
                    currentNode := map.private_trees[fullCurrentIndex]
                    currentNode:setNodeIndexWithOtherItemIndex(newNodeIndex)
                    map:private_trees:setItem(fullCurrentIndex, currentNode)
                    map:private_trees += MapTreeNode
                    if newNodeIndex == 16777215
                        then
                            firstNodeOfTreeIndex += 16777215
                            currentNodeIndex = 0
                            keyHash = firstHash
                            continue first
                        else currentNodeIndex = newNodeIndex
                nextNodeIndex == 16777215
                    firstNodeOfTreeIndex += 16777215
                    currentNodeIndex = 0
                    keyHash = firstHash
                    continue first
                default
                    currentNodeIndex = nextNodeIndex
        break
    fullCurrentIndex .= firstNodeOfTreeIndex + currentNodeIndex
    currentNode := map.private_trees[fullCurrentIndex]
    currentNode:setItemIndex(itemIndex)
    map:private_trees:setItem(fullCurrentIndex, currentNode)
    map:private_keysAndItems:setItem(itemIndex, Box(Pair(map[0], map[1])).create(keyAndItem))

func create(mapType Map(_, _), keysAndItems [Pair(mapType[0], mapType[1])]) mapType
    rules
        final = mapType[0] > Hashed & mapType[0] > Equal
    parse _, keyAndItem <- keysAndItems
        result += keyAndItem

func getItem(map Map(_, _), key map[0]) Box(map[1])
    rules
        final = key > Hashed & key > Equal
    if map.init?()
        then
            keyHash := key.getSmallHash()
            firstNodeOfTreeIndex := 0
            currentNodeIndex := 0
            countOfLoops .= #key.getSmallHashSize() * 2.convertTo(UInt8)
            firstHash .= keyHash
            for
                for loopID := UInt8; loopID < countOfLoops; loopID++
                    partOfKeyHash .= (keyHash & 15.convertTo(UInt32)).convertTo(UInt8)
                    keyHash >>= 4
                    fullCurrentIndex .= firstNodeOfTreeIndex + currentNodeIndex
                    nextNodeIndex .= map.private_trees[fullCurrentIndex][partOfKeyHash]
                    mif
                        nextNodeIndex == 0
                            break all
                        nextNodeIndex == 16777215
                            firstNodeOfTreeIndex += 16777215
                            currentNodeIndex = 0
                            keyHash = firstHash
                            continue first
                        default
                            currentNodeIndex = nextNodeIndex
                for
                    fullCurrentIndex .= firstNodeOfTreeIndex + currentNodeIndex
                    itemIndex .= map.private_trees[fullCurrentIndex].getItemIndex()
                    if itemIndex == 0
                        then break
                    if keyAndItem .= map.private_keysAndItems[itemIndex]; keyAndItem.item?() && keyAndItem[].first == key
                        then
                            result:put(keyAndItem[].second)
                            break all
                    nextNodeIndex .= map.private_trees[fullCurrentIndex].getNodeIndexWithOtherItemIndex()
                    mif
                        nextNodeIndex == 0
                            break all
                        nextNodeIndex == 16777215
                            firstNodeOfTreeIndex += 16777215
                            currentNodeIndex = 0
                            keyHash = firstHash
                            continue first
                        default
                            currentNodeIndex = nextNodeIndex
                break

func getLength(a Map(_, _)) UInt64
    attributes
        alwaysInline
    if a.init?()
        then result = a.private_keysAndItems.getLength() - 1 - a.private_numberOfHiddenItems.convertTo(UInt64)

func init(a Map(_, _)) a
    attributes
        alwaysInline
    result:private_keysAndItems = [Box(Pair(a[0], a[1]))].init(256).getFirstN(1)
    result:private_trees = [MapTreeNode].init(512).getFirstN(1)

func init?(a Map(_, _)) Bool
    attributes
        alwaysInline
    result = a.private_trees.getLength() != 0

func parse_first(map Map(_, _)) UInt64
    attributes
        alwaysInline
    result = 1
    for ; result < map.private_keysAndItems.getLength(); result++
        if map.private_keysAndItems[result].item?()
            then break

func parse_haveItem?(map Map(_, _), index UInt64) Bool
    attributes
        alwaysInline
    result = index < map.private_keysAndItems.getLength()

func parse_item(map Map(_, _), index UInt64) map[1]
    attributes
        alwaysInline
    result = map.private_keysAndItems[index][].second

func parse_key(map Map(_, _), index UInt64) map[0]
    attributes
        alwaysInline
    result = map.private_keysAndItems[index][].first

func parse_next(map Map(_, _), index UInt64) UInt64
    attributes
        alwaysInline
    result = index + 1
    for ; result < map.private_keysAndItems.getLength(); result++
        if map.private_keysAndItems[result].item?()
            then break

proc unnamed(:map Map(_, _)) #1
    attributes
        noInline
        id = "private delete hidden items in map procedure (standart module)"
    rules
        final = map[0] > Hashed & map[0] > Equal
    newMap := #map.init()
    parse key, item <- map
        newMap:add(key, item)
    map = newMap

proc subEq(:map Map(_, _), key map[0])
    rules
        final = key > Hashed & key > Equal
    if map.init?()
        then
            keyHash := key.getSmallHash()
            firstNodeOfTreeIndex := 0
            currentNodeIndex := 0
            countOfLoops .= #key.getSmallHashSize() * 2.convertTo(UInt8)
            firstHash .= keyHash
            for
                for loopID := UInt8; loopID < countOfLoops; loopID++
                    partOfKeyHash .= (keyHash & 15.convertTo(UInt32)).convertTo(UInt8)
                    keyHash >>= 4
                    fullCurrentIndex .= firstNodeOfTreeIndex + currentNodeIndex
                    nextNodeIndex .= map.private_trees[fullCurrentIndex][partOfKeyHash]
                    mif
                        nextNodeIndex == 0
                            break all
                        nextNodeIndex == 16777215
                            firstNodeOfTreeIndex += 16777215
                            currentNodeIndex = 0
                            keyHash = firstHash
                            continue first
                        default
                            currentNodeIndex = nextNodeIndex
                for
                    fullCurrentIndex .= firstNodeOfTreeIndex + currentNodeIndex
                    itemIndex .= map.private_trees[fullCurrentIndex].getItemIndex()
                    if itemIndex == 0
                        then break
                    if keyAndItem .= map.private_keysAndItems[itemIndex]; keyAndItem.item?() && keyAndItem[].first == key
                        then
                            map:private_keysAndItems:setItem(itemIndex, Box(Pair(map[0], map[1])))
                            nextNode .= map.private_trees[map.private_trees[fullCurrentIndex].getNodeIndexWithOtherItemIndex()]
                            currentNode := map.private_trees[fullCurrentIndex]
                            currentNode:setItemIndex(nextNode.getItemIndex())
                            currentNode:setNodeIndexWithOtherItemIndex(nextNode.getNodeIndexWithOtherItemIndex())
                            map:private_trees:setItem(fullCurrentIndex, currentNode)
                            map:private_numberOfHiddenItems++
                            if < map.private_numberOfHiddenItems == UInt16
                                then builtInCallFunctionByID("private delete hidden items in map procedure (standart module)", map)
                            break all
                    nextNodeIndex .= map.private_trees[fullCurrentIndex].getNodeIndexWithOtherItemIndex()
                    mif
                        nextNodeIndex == 0
                            break all
                        nextNodeIndex == 16777215
                            firstNodeOfTreeIndex += 16777215
                            currentNodeIndex = 0
                            keyHash = firstHash
                            continue first
                        default
                            currentNodeIndex = nextNodeIndex
                break
