rules
    1 = type == @func | type == @proc
    join 1 Equal

func equal(a, b a) Bool
    attributes
        alwaysInline
    rules
        final = a == @func | a == @proc
    C
        result_ = a_ == b_;

func filter(f, slice [_]) slice
    attributes
        alwaysInline
    rules
        final = f == @(slice[0]) -> Bool
    parse _, item <- slice
        if @f(item)
            then result += item
    if slice.string?()
        then result:setStringFlag()

func foldl(f, a, slice [_]) a
    attributes
        alwaysInline
    rules
        final = f == @(a, slice[0]) -> a
    result = a
    parse _, item <- slice
        result = @f(result, item)

func foldr(f, a, slice [_]) a
    attributes
        alwaysInline
    rules
        final = f == @(slice[0], a) -> a
    result = a
    for index := slice.getLength() - 1; index != UInt64.maxValue(); index--
        result = @f(slice[index], result)

func map(f, slice [_]) [f[-]]
    attributes
        alwaysInline
    rules
        final = f == @(slice[0]) -> _
    result = [f[-]].init(slice.getLength())
    parse index, item <- slice
        result:setItem(index, @f(item))

func map(f, a, slice [_]) [f[-]]
    attributes
        alwaysInline
    rules
        final = f == @(slice[0], a) -> _
    result = [f[-]].init(slice.getLength())
    parse index, item <- slice
        result:setItem(index, @f(item, a))

func zip(slice1 [_], slice2 [_]) [Pair(slice1[0], slice2[0])]
    attributes
        alwaysInline
    minLength .= slice1.getLength().min(slice2.getLength())
    result = [Pair(slice1[0], slice2[0])].init(minLength)
    for index := 0; index < minLength; index++
        result:setItem(index, Pair(slice1[0], slice2[0]).create(slice1[index], slice2[index]))

func zip(slice1 [_], slice2 [_], slice3 [_]) [Triple(slice1[0], slice2[0], slice3[0])]
    attributes
        alwaysInline
    minLength .= slice1.getLength().min(slice2.getLength()).min(slice3.getLength())
    result = [Triple(slice1[0], slice2[0], slice3[0])].init(minLength)
    for index := 0; index < minLength; index++
        result:setItem(index, Triple(slice1[0], slice2[0], slice3[0]).create(slice1[index], slice2[index], slice3[index]))

func zipWith(f, slice1 [_], slice2 [_]) [f[-]]
    attributes
        alwaysInline
    rules
        final = f == @(slice1[0], slice2[0]) -> _
    minLength .= slice1.getLength().min(slice2.getLength())
    result = [f[-]].init(minLength)
    for index := 0; index < minLength; index++
        result:setItem(index, @f(slice1[index], slice2[index]))

func zipWith(f, slice1 [_], slice2 [_], slice3 [_]) [f[-]]
    attributes
        alwaysInline
    rules
        final = f == @(slice1[0], slice2[0], slice3[0]) -> _
    minLength .= slice1.getLength().min(slice2.getLength()).min(slice3.getLength())
    result = [f[-]].init(minLength)
    for index := 0; index < minLength; index++
        result:setItem(index, @f(slice1[index], slice2[index], slice3[index]))

func zipWith(f, slice1 [_], slice2 [_], slice3 [_], slice4 [_]) [f[-]]
    attributes
        alwaysInline
    rules
        final = f == @(slice1[0], slice2[0], slice3[0], slice4[0]) -> _
    minLength .= slice1.getLength().min(slice2.getLength()).min(slice3.getLength()).min(slice4.getLength())
    result = [f[-]].init(minLength)
    for index := 0; index < minLength; index++
        result:setItem(index, @f(slice1[index], slice2[index], slice3[index], slice4[index]))
