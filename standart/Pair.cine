type Pair(first, second)
    first first
    second second

rules
    1 = type == Pair(_, _) & type[0] > Binary & type[1] > Binary
    join 1 Binary
    2 = type == Pair(_, _) & type[0] > Equal & type[1] > Equal
    join 2 Equal
    3 = type == Pair(_, _) & type[0] > StringWriter & type[1] > StringWriter
    join 3 StringWriter
    4 = type == Pair(_, _) & type[0] > Hashed & type[1] > Hashed
    join 4 Hashed
    5 = type == Pair(_, _) & type[0] > Bits & type[1] > Bits
    join 5 Bits

proc addEq(:data BinaryData, pair Pair(_, _))
    rules
        final = pair > Binary
    data += pair.first
    data += pair.second

func and(a Pair(_, _), b a) a
    attributes
        alwaysInline
    rules
        final = a > Bits
    result:first = a.first & b.first
    result:second = a.second & b.second

func create(pairType Pair(_, _), first pairType[0], second pairType[1]) pairType
    attributes
        alwaysInline
    result:first = first
    result:second = second

func equal(a Pair(_, _), b a) Bool
    attributes
        alwaysInline
    rules
        final = a > Equal
    result = a.first == b.first && a.second == b.second

func getFromBinaryData(pair Pair(_, _), data BinaryData, :position UInt64) pair
    rules
        final = pair > Binary
    result:first = #pair[0].getFromBinaryData(data, position)
    result:second = #pair[1].getFromBinaryData(data, position)

func getHash(pair Pair(_, _)) UInt64
    attributes
        alwaysInline
    rules
        final = pair > Hashed
    result = pair.first.getHash()
    result += result << 10
    result ^= result >> 6
    result += getStaticRandomNumber()
    result += result << 10
    result ^= result >> 6
    result += pair.second.getHash()
    result += result << 10
    result ^= result >> 6
    result += result << 3
    result ^= result >> 11
    result += result << 15

func getHashSize(pair Pair(_, _)) UInt8
    attributes
        alwaysInline
    rules
        final = pair > Hashed
    result = 8.convertTo(UInt8)

func not(pair Pair(_, _)) pair
    attributes
        alwaysInline
    rules
        final = pair > Bits
    result:first = pair.first.not()
    result:second = pair.second.not()

func or(a Pair(_, _), b a) a
    attributes
        alwaysInline
    rules
        final = a > Bits
    result:first = a.first | b.first
    result:second = a.second | b.second

func shl(pair Pair(_, _), shifts > BasicUnsignedInteger) pair
    attributes
        alwaysInline
    rules
        final = pair > Bits
    result:first = pair.first << shifts
    result:second = pair.second << shifts

func shr(pair Pair(_, _), shifts > BasicUnsignedInteger) pair
    attributes
        alwaysInline
    rules
        final = pair > Bits
    result:first = pair.first >> shifts
    result:second = pair.second >> shifts

func toString(pair Pair(_, _)) [UInt8]
    rules
        final = pair > StringWriter
    result = "(".join({
        pair.first.toString(), ", ",
        pair.second.toString(), ")")
    }

func xor(a Pair(_, _), b a) a
    attributes
        alwaysInline
    rules
        final = a > Bits
    result:first = a.first ^ b.first
    result:second = a.second ^ b.second
