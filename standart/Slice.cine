rules
    1 = type == [_] & type[0] > Binary
    join 1 Binary
    2 = type == [_] & type[0] > Bits
    join 2 Bits
    3 = type == [_] & type[0] > Ordered
    join 3 Ordered
    4 = type == [_] & type[0] > Equal
    join 4 Equal
    5 = type == [_] & type[0] > Hashed
    join 5 Hashed
    6 = type == [_] & type[0] > StringWriter
    join 6 StringWriter

func add(slice [_], newItem slice[0]) slice
    result = #slice.init(slice.getLength() + 1)
    result:copyToFirst(slice)
    result:setLast(newItem)
    if slice.string?()
        then result:setStringFlag()

func add(firstPart [_], lastPart firstPart) firstPart
    if length .= firstPart.getLength() + lastPart.getLength(); length != 0
        then
            result = #firstPart.init(length)
            result:copyToFirst(firstPart)
            result:copyToLast(lastPart)
    if firstPart.string?()
        then result:setStringFlag()

proc addEq(:data BinaryData, slice [_])
    rules
        final = slice > Binary
    data += slice.string?()
    data += slice.getLength()
    parse _, item <- slice
        data += item

proc addEq(:slice [_], newItem slice[0])
    initLength .= slice.getLength()
    isString .= slice.string?()
    if slice.getCapacity() <= initLength || slice.use?()
        then
            newSlice := #slice.init(((initLength + initLength / 4) / 64 + 1) * 64)
            newSlice:copyToFirst(slice)
            slice = newSlice.getFirstN(initLength + 1)
        else
            C
                slice_->length++;
    slice:setItem(initLength, newItem)
    if isString
        then slice:setStringFlag()

proc addEq(:slice [_], lastPart slice)
    newLength .= slice.getLength() + lastPart.getLength()
    isString .= slice.string?()
    if slice.getCapacity() < newLength || slice.use?()
        then
            newSlice := #slice.init(((newLength + newLength / 4) / 64 + 1) * 64)
            newSlice:copyToFirst(slice)
            slice = newSlice.getFirstN(newLength)
        else
            C
                slice_->length = newLength_;
    slice:copyToLast(lastPart)
    if isString
        then slice:setStringFlag()

func and(slice1 [_], slice2 slice1) slice1
    attributes
        alwaysInline
    rules
        final = slice1 > Bits
    flag debug is set?
        then debugMessage(slice1.getLength() != slice2.getLength(), "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - the size of the first slice is different from the size of the second.")
    result = #slice1.init(slice1.getLength())
    parse index, item <- slice1
        result:setItem(index, item & slice2[index])
    if slice1.string?()
        then result:setStringFlag()

proc andEq(:slice1 [_], slice2 slice1)
    attributes
        alwaysInline
    rules
        final = slice1 > Bits
    flag debug is set?
        then debugMessage(slice1.getLength() != slice2.getLength(), "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - the size of the first slice is different from the size of the second.")
    parse index, item <- slice2
        slice1:setItem(index, slice1[index] & item)

func asSlice(slice [_]) slice
    attributes
        alwaysInline
    result = slice
    C
        result_.isString = false;

func asString(slice [_]) slice
    attributes
        alwaysInline
    result = slice
    C
        result_.isString = true;

proc clear(:slice [_])
    slice:fillWithZeros()
    C
        slice_->length = 0;

func clone(slice [_]) slice
    if slice.getLength() != 0
        then
            result = #slice.init(slice.getLength())
            result:copyToFirst(slice)
    if slice.string?()
        then result:setStringFlag()

func contain?(slice [_], item slice[0]) Bool
    attributes
        alwaysInline
    result = slice.look(item).item?()

func contain?(slice [_], itemsList VAList(slice[0])) Bool
    attributes
        alwaysInline
    rules
        final = slice > Equal
    result = slice.look(itemsList).item?()

func contain?(slice [_], subSlice slice) Bool
    attributes
        alwaysInline
    rules
        final = slice > Equal
    result = slice.look(subSlice).item?()

func contain?(slice [_], subSlicesList VAList(slice)) Bool
    attributes
        alwaysInline
    rules
        final = slice > Equal
    result = slice.look(subSlicesList).item?()

proc copy(:slice [_], from > BasicUnsignedInteger, to > BasicUnsignedInteger, source slice)
    include
        #include <string.h>
    flag debug is set?
        then
            debugMessage(from.convertTo(UInt64) > to.convertTo(UInt64), "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - the first index is greater than the last index.")
            debugMessage(from.convertTo(UInt64) > slice.getLength(), "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - the first index is too large.")
            debugMessage(to.convertTo(UInt64) > slice.getLength(), "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - the last index is too large.")
            debugMessage(to.convertTo(UInt64) - from.convertTo(UInt64) > source.getLength(), "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - the source is too short.")
    if length .= to - from; length != 0
        then haveLink? slice[0]
            then
                for index := from; index < to; index++
                    slice:setItem(index, source[index - from])
            else
                if slice.use?()
                    then slice = slice.clone()
                itemSize .= #slice[0].getTypeSize()
                C
                    memcpy(slice_->items + from_, source_.items, length_ * itemSize_);

proc copyToFirst(:slice [_], source slice)
    slice:copy(0, source.getLength(), source)

proc copyToLast(:slice [_], source slice)
    slice:copy(slice.getLength() - source.getLength(), slice.getLength(), source)

func count(slice [_], item slice[0]) UInt64
    attributes
        alwaysInline
    rules
        final = slice > Equal
    parse _, sliceItem <- slice
        if item == sliceItem
            then result++

func count(slice [_], itemsList VAList(slice[0])) UInt64
    attributes
        alwaysInline
    rules
        final = slice > Equal
    flag debug is set?
        then debugMessage(itemsList.getLength() == UInt8, "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - there is nothing to count.")
    parse _, sliceItem <- slice
        parse _, listItem <- itemsList
            if sliceItem == listItem
                then
                    result++
                    break

func count(slice [_], subSlice slice) UInt64
    attributes
        alwaysInline
    rules
        final = slice > Equal
    flag debug is set?
        then debugMessage(subSlice.getLength() == 0, "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - there is nothing to count.")
    mutSlice := slice
    firstItem .= subSlice[0]
    for mutSlice.getLength() >= subSlice.getLength()
        firstItemIndex .= mutSlice.look(firstItem)
        if firstItemIndex.empty?()
            then break
        mutSlice = mutSlice.getAllExceptFirstN(firstItemIndex[])
        if mutSlice.hasPrefix?(subSlice)
            then
                result++
                mutSlice = mutSlice.getAllExceptFirstN(subSlice.getLength())
            else mutSlice = mutSlice.getAllExceptFirst()

func count(slice [_], subSlicesList VAList(slice)) UInt64
    attributes
        alwaysInline
    rules
        final = slice > Equal
    flag debug is set?
        then debugMessage(subSlicesList.getLength() == UInt8, "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - there is nothing to count.")
    mutSlice := slice
    firstsItems := VAList(slice[0])
    enslave(firstsItems)
    listLength .= subSlicesList.getLength()
    C
        firstsItems_.length = listLength_;
    minLength := UInt64.maxValue()
    parse index, item <- subSlicesList
        flag debug is set?
            then debugMessage(item.getLength() == 0, "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - there is nothing to count.")
        minLength = minLength.min(item.getLength())
        C
            firstsItems_.items[index_] = item_.items[0];
    for mutSlice.getLength() >= minLength
        firstItemAndIndex .= mutSlice.look(firstsItems)
        if firstItemAndIndex.empty?()
            then break
        mutSlice = mutSlice.getAllExceptFirstN(firstItemAndIndex[].second)
        countOfDeletingItems := 1
        parse _, item <- subSlicesList
            if mutSlice.hasPrefix?(item)
                then
                    result++
                    countOfDeletingItems = item.getLength()
                    break
        mutSlice = mutSlice.getAllExceptFirstN(countOfDeletingItems)

func dummy(sliceType [_], numberOfItems > BasicUnsignedInteger) sliceType
    attributes
        alwaysInline
    include
        #include <stdlib.h>
        #include <stdio.h>
    if numberOfItems != 0
        then
            C
                result_.array = (##sliceType[0]##*)calloc(numberOfItems_, sizeof(##sliceType[0]##));
                result_.useCounter = (uint64_t*)(malloc(sizeof(uint64_t)));
                if (__builtin_expect(result_.array == NULL || result_.useCounter == NULL, false)){
                    fprintf(stderr, "Not enought memory.\n");
                    abort();
                }
                *result_.useCounter = 1;
                result_.items = result_.array;
                result_.capacity = numberOfItems_;
                result_.initCapacity = numberOfItems_;

func equal(slice1 [_], slice2 slice1) Bool
    attributes
        alwaysInline
    rules
        final = slice1 > Equal
    if length .= slice1.getLength(); result = length == slice2.getLength(); result && length != 0
        then parse index, item <- slice1
            if result = item == slice2[index]; !result
                then break

proc fillWithZeros(:slice [_])
    include
        #include <string.h>
    if slice.getLength() != 0
        then
            haveLink? slice[0]
                then for index := 0; index < slice.getLength(); index++
                    slice:setItem(index, #slice[0])
                else
                    if slice.use?()
                        then slice = slice.clone()
                    itemSize .= #slice[0].getTypeSize()
                    C
                        memset(slice_->items, 0, slice_->length * itemSize_);

proc free(slice [_])
    include
        #include <stdlib.h>
    needToFree := false
    C
        if (slice_.useCounter != (uint64_t*){0}) {
            needToFree_ = *slice_.useCounter < 2;
            (*slice_.useCounter)--;
        }
    if needToFree
        then
            haveLink? slice[0]
                then for index := 0; index < slice.getInitCapacity(); index++
                    freeObject := #slice[0]
                    C
                        freeObject_ = slice_.array[index_];
            C
                free(slice_.useCounter);
                free(slice_.array);

func getAllExceptFirst(slice [_]) slice
    attributes
        alwaysInline
    result = slice.getSlice(1, slice.getLength())

func getAllExceptFirstN(slice [_], n > BasicUnsignedInteger) slice
    attributes
        alwaysInline
    result = slice.getSlice(n, slice.getLength())

func getAllExceptLast(slice [_]) slice
    attributes
        alwaysInline
    result = slice.getSlice(0, slice.getLength() - 1)

func getAllExceptLastN(slice [_], n > BasicUnsignedInteger) slice
    attributes
        alwaysInline
    result = slice.getSlice(0, slice.getLength() - n.convertTo(UInt64))

func getCapacity(slice [_]) UInt64
    attributes
        alwaysInline
    C
        result_ = slice_.capacity;

func getFirst(slice [_]) slice[0]
    attributes
        alwaysInline
    result = slice[0]

func getFirstN(slice [_], n > BasicUnsignedInteger) slice
    attributes
        alwaysInline
    result = slice.getSlice(0, n)

func getFromBinaryData(sliceType [_], data BinaryData, :position UInt64) sliceType
    rules
        final = sliceType > Binary
    isString .= Bool.getFromBinaryData(data, position)
    length .= UInt64.getFromBinaryData(data, position)
    result = #sliceType.init(length)
    for index := 0; index < length; index++
        result:setItem(index, #sliceType[0].getFromBinaryData(data, position))
    if isString
        then result:setStringFlag()

func getHash(slice [_]) UInt64
    attributes
        alwaysInline
    rules
        final = slice > Hashed
    result = getStaticRandomNumber()
    result += slice.getLength()
    result += result << 10
    result ^= result >> 6
    parse index, item <- slice
        result += item.getHash()
        result += result << 10
        result ^= result >> 6
    result += result << 3
    result ^= result >> 11
    result += result << 15

func getHashSize(sliceType [_]) UInt8
    attributes
        alwaysInline
    rules
        final = sliceType > Hashed
    result = 8.convertTo(UInt8)

func getInitCapacity(slice [_]) UInt64
    attributes
        alwaysInline
    C
        result_ = slice_.initCapacity;

func getItem(slice [_], index > BasicUnsignedInteger) slice[0]
    attributes
        alwaysInline
    flag debug is set?
        then debugMessage(index.convertTo(UInt64) >= slice.getLength(), "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - the index is too large.")
    C
        result_ = slice_.items[index_];
    result.use()

func getLast(slice [_]) slice[0]
    attributes
        alwaysInline
    result = slice[slice.getLength() - 1]

func getLastN(slice [_], n > BasicUnsignedInteger) slice
    attributes
        alwaysInline
    result = slice.getSlice(slice.getLength() - n.convertTo(UInt64), slice.getLength())

func getLength(slice [_]) UInt64
    attributes
        alwaysInline
    C
        result_ = slice_.length;

func getSlice(slice [_], from > BasicUnsignedInteger, to > BasicUnsignedInteger) slice
    attributes
        alwaysInline
    include
        #include <string.h>
    flag debug is set?
        then
            debugMessage(from.convertTo(UInt64) > to.convertTo(UInt64), "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - the first index is greater than the last index.")
            debugMessage(from.convertTo(UInt64) > slice.getLength(), "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - the first index is too large.")
            debugMessage(to.convertTo(UInt64) > slice.getLength(), "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - the last index is too large.")
    newLength .= to - from
    if newLength != 0
        then
            C
                result_.length = newLength_;
                result_.capacity = slice_.capacity - from_;
                result_.array = slice_.array;
                result_.initCapacity = slice_.initCapacity;
                result_.items = slice_.items + from_;
                result_.useCounter = slice_.useCounter;
            result.use()
    if slice.string?()
        then result:setStringFlag()

func greater(slice1 [_], slice2 slice1) Bool
    attributes
        alwaysInline
    rules
        final = slice1 > Ordered
    if minLength .= slice1.getLength().min(slice2.getLength()); minLength != 0
        then for index := 0; index < minLength; index++
            item1 .= slice1[index]
            item2 .= slice2[index]
            mif
                item1 > item2
                    return true
                item2 > item1
                    return false
    result = slice1.getLength() > slice2.getLength()

func greaterOrEqual(slice1 [_], slice2 slice1) Bool
    attributes
        alwaysInline
    rules
        final = slice1 > Ordered
    if minLength .= slice1.getLength().min(slice2.getLength()); minLength != 0
        then for index := 0; index < minLength; index++
            item1 .= slice1[index]
            item2 .= slice2[index]
            mif
                item1 > item2
                    return true
                item2 > item1
                    return false
    result = slice1.getLength() >= slice2.getLength()

func hasPrefix?(slice [_], prefix slice) Bool
    attributes
        alwaysInline
    rules
        final = slice > Equal
    flag debug is set?
        then debugMessage(prefix.getLength() == 0, "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - prefix is empty.")
    if result = slice.getLength() >= prefix.getLength(); result
        then result = slice.getFirstN(prefix.getLength()) == prefix

func hasSuffix?(slice [_], suffix slice) Bool
    attributes
        alwaysInline
    rules
        final = slice > Equal
    flag debug is set?
        then debugMessage(suffix.getLength() == 0, "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - suffix is empty.")
    if result = slice.getLength() >= suffix.getLength(); result
        then result = slice.getLastN(suffix.getLength()) == suffix

func init(sliceType [_], numberOfItems > BasicUnsignedInteger) sliceType
    attributes
        alwaysInline
    result = #sliceType.dummy(numberOfItems)
    C
        result_.length = numberOfItems_;

func join(slice [_], js1 slice, js2 slice) slice
    length .= slice.getLength() + js1.getLength() + js2.getLength()
    result = #slice.dummy(length)
    if slice.string?()
        then result:setStringFlag()
    result += slice
    result += js1
    result += js2

func join(slice [_], js1 slice, js2 slice, js3 slice) slice
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength()
    result = #slice.dummy(length)
    if slice.string?()
        then result:setStringFlag()
    result += slice
    result += js1
    result += js2
    result += js3

func join(slice [_], js1 slice, js2 slice, js3 slice, js4 slice) slice
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength()
    result = #slice.dummy(length)
    if slice.string?()
        then result:setStringFlag()
    result += slice
    result += js1
    result += js2
    result += js3
    result += js4

func join(slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice) slice
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength()
    result = #slice.dummy(length)
    if slice.string?()
        then result:setStringFlag()
    result += slice
    result += js1
    result += js2
    result += js3
    result += js4
    result += js5

func join(slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice) slice
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength()
    result = #slice.dummy(length)
    if slice.string?()
        then result:setStringFlag()
    result += slice
    result += js1
    result += js2
    result += js3
    result += js4
    result += js5
    result += js6

func join(slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice) slice
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength()
    result = #slice.dummy(length)
    if slice.string?()
        then result:setStringFlag()
    result += slice
    result += js1
    result += js2
    result += js3
    result += js4
    result += js5
    result += js6
    result += js7

func join(slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice) slice
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength()
    result = #slice.dummy(length)
    if slice.string?()
        then result:setStringFlag()
    result += slice
    result += js1
    result += js2
    result += js3
    result += js4
    result += js5
    result += js6
    result += js7
    result += js8

func join(slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice) slice
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength()
    result = #slice.dummy(length)
    if slice.string?()
        then result:setStringFlag()
    result += slice
    result += js1
    result += js2
    result += js3
    result += js4
    result += js5
    result += js6
    result += js7
    result += js8
    result += js9

func join(slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice, js10 slice) slice
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength() + js10.getLength()
    result = #slice.dummy(length)
    if slice.string?()
        then result:setStringFlag()
    result += slice
    result += js1
    result += js2
    result += js3
    result += js4
    result += js5
    result += js6
    result += js7
    result += js8
    result += js9
    result += js10

func join(slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice, js10 slice, js11 slice) slice
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength() + js10.getLength() + js11.getLength()
    result = #slice.dummy(length)
    if slice.string?()
        then result:setStringFlag()
    result += slice
    result += js1
    result += js2
    result += js3
    result += js4
    result += js5
    result += js6
    result += js7
    result += js8
    result += js9
    result += js10
    result += js11

func join(slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice, js10 slice, js11 slice, js12 slice) slice
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength() + js10.getLength() + js11.getLength() + js12.getLength()
    result = #slice.dummy(length)
    if slice.string?()
        then result:setStringFlag()
    result += slice
    result += js1
    result += js2
    result += js3
    result += js4
    result += js5
    result += js6
    result += js7
    result += js8
    result += js9
    result += js10
    result += js11
    result += js12

func join(slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice, js10 slice, js11 slice, js12 slice, js13 slice) slice
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength() + js10.getLength() + js11.getLength() + js12.getLength() + js13.getLength()
    result = #slice.dummy(length)
    if slice.string?()
        then result:setStringFlag()
    result += slice
    result += js1
    result += js2
    result += js3
    result += js4
    result += js5
    result += js6
    result += js7
    result += js8
    result += js9
    result += js10
    result += js11
    result += js12
    result += js13

func join(slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice, js10 slice, js11 slice, js12 slice, js13 slice, js14 slice) slice
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength() + js10.getLength() + js11.getLength() + js12.getLength() + js13.getLength() + js14.getLength()
    result = #slice.dummy(length)
    if slice.string?()
        then result:setStringFlag()
    result += slice
    result += js1
    result += js2
    result += js3
    result += js4
    result += js5
    result += js6
    result += js7
    result += js8
    result += js9
    result += js10
    result += js11
    result += js12
    result += js13
    result += js14

func join(slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice, js10 slice, js11 slice, js12 slice, js13 slice, js14 slice, js15 slice) slice
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength() + js10.getLength() + js11.getLength() + js12.getLength() + js13.getLength() + js14.getLength() + js15.getLength()
    result = #slice.dummy(length)
    if slice.string?()
        then result:setStringFlag()
    result += slice
    result += js1
    result += js2
    result += js3
    result += js4
    result += js5
    result += js6
    result += js7
    result += js8
    result += js9
    result += js10
    result += js11
    result += js12
    result += js13
    result += js14
    result += js15

func join(slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice, js10 slice, js11 slice, js12 slice, js13 slice, js14 slice, js15 slice, js16 slice) slice
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength() + js10.getLength() + js11.getLength() + js12.getLength() + js13.getLength() + js14.getLength() + js15.getLength() + js16.getLength()
    result = #slice.dummy(length)
    if slice.string?()
        then result:setStringFlag()
    result += slice
    result += js1
    result += js2
    result += js3
    result += js4
    result += js5
    result += js6
    result += js7
    result += js8
    result += js9
    result += js10
    result += js11
    result += js12
    result += js13
    result += js14
    result += js15
    result += js16

func join(slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice, js10 slice, js11 slice, js12 slice, js13 slice, js14 slice, js15 slice, js16 slice, js17 slice) slice
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength() + js10.getLength() + js11.getLength() + js12.getLength() + js13.getLength() + js14.getLength() + js15.getLength() + js16.getLength() + js17.getLength()
    result = #slice.dummy(length)
    if slice.string?()
        then result:setStringFlag()
    result += slice
    result += js1
    result += js2
    result += js3
    result += js4
    result += js5
    result += js6
    result += js7
    result += js8
    result += js9
    result += js10
    result += js11
    result += js12
    result += js13
    result += js14
    result += js15
    result += js16
    result += js17

func join(slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice, js10 slice, js11 slice, js12 slice, js13 slice, js14 slice, js15 slice, js16 slice, js17 slice, js18 slice) slice
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength() + js10.getLength() + js11.getLength() + js12.getLength() + js13.getLength() + js14.getLength() + js15.getLength() + js16.getLength() + js17.getLength() + js18.getLength()
    result = #slice.dummy(length)
    if slice.string?()
        then result:setStringFlag()
    result += slice
    result += js1
    result += js2
    result += js3
    result += js4
    result += js5
    result += js6
    result += js7
    result += js8
    result += js9
    result += js10
    result += js11
    result += js12
    result += js13
    result += js14
    result += js15
    result += js16
    result += js17
    result += js18

func join(slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice, js10 slice, js11 slice, js12 slice, js13 slice, js14 slice, js15 slice, js16 slice, js17 slice, js18 slice, js19 slice) slice
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength() + js10.getLength() + js11.getLength() + js12.getLength() + js13.getLength() + js14.getLength() + js15.getLength() + js16.getLength() + js17.getLength() + js18.getLength() + js19.getLength()
    result = #slice.dummy(length)
    if slice.string?()
        then result:setStringFlag()
    result += slice
    result += js1
    result += js2
    result += js3
    result += js4
    result += js5
    result += js6
    result += js7
    result += js8
    result += js9
    result += js10
    result += js11
    result += js12
    result += js13
    result += js14
    result += js15
    result += js16
    result += js17
    result += js18
    result += js19

func join(slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice, js10 slice, js11 slice, js12 slice, js13 slice, js14 slice, js15 slice, js16 slice, js17 slice, js18 slice, js19 slice, js20 slice) slice
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength() + js10.getLength() + js11.getLength() + js12.getLength() + js13.getLength() + js14.getLength() + js15.getLength() + js16.getLength() + js17.getLength() + js18.getLength() + js19.getLength() + js20.getLength()
    result = #slice.dummy(length)
    if slice.string?()
        then result:setStringFlag()
    result += slice
    result += js1
    result += js2
    result += js3
    result += js4
    result += js5
    result += js6
    result += js7
    result += js8
    result += js9
    result += js10
    result += js11
    result += js12
    result += js13
    result += js14
    result += js15
    result += js16
    result += js17
    result += js18
    result += js19
    result += js20

func join(slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice, js10 slice, js11 slice, js12 slice, js13 slice, js14 slice, js15 slice, js16 slice, js17 slice, js18 slice, js19 slice, js20 slice, js21 slice) slice
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength() + js10.getLength() + js11.getLength() + js12.getLength() + js13.getLength() + js14.getLength() + js15.getLength() + js16.getLength() + js17.getLength() + js18.getLength() + js19.getLength() + js20.getLength() + js21.getLength()
    result = #slice.dummy(length)
    if slice.string?()
        then result:setStringFlag()
    result += slice
    result += js1
    result += js2
    result += js3
    result += js4
    result += js5
    result += js6
    result += js7
    result += js8
    result += js9
    result += js10
    result += js11
    result += js12
    result += js13
    result += js14
    result += js15
    result += js16
    result += js17
    result += js18
    result += js19
    result += js20
    result += js21

func join(slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice, js10 slice, js11 slice, js12 slice, js13 slice, js14 slice, js15 slice, js16 slice, js17 slice, js18 slice, js19 slice, js20 slice, js21 slice, js22 slice) slice
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength() + js10.getLength() + js11.getLength() + js12.getLength() + js13.getLength() + js14.getLength() + js15.getLength() + js16.getLength() + js17.getLength() + js18.getLength() + js19.getLength() + js20.getLength() + js21.getLength() + js22.getLength()
    result = #slice.dummy(length)
    if slice.string?()
        then result:setStringFlag()
    result += slice
    result += js1
    result += js2
    result += js3
    result += js4
    result += js5
    result += js6
    result += js7
    result += js8
    result += js9
    result += js10
    result += js11
    result += js12
    result += js13
    result += js14
    result += js15
    result += js16
    result += js17
    result += js18
    result += js19
    result += js20
    result += js21
    result += js22

func join(slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice, js10 slice, js11 slice, js12 slice, js13 slice, js14 slice, js15 slice, js16 slice, js17 slice, js18 slice, js19 slice, js20 slice, js21 slice, js22 slice, js23 slice) slice
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength() + js10.getLength() + js11.getLength() + js12.getLength() + js13.getLength() + js14.getLength() + js15.getLength() + js16.getLength() + js17.getLength() + js18.getLength() + js19.getLength() + js20.getLength() + js21.getLength() + js22.getLength() + js23.getLength()
    result = #slice.dummy(length)
    if slice.string?()
        then result:setStringFlag()
    result += slice
    result += js1
    result += js2
    result += js3
    result += js4
    result += js5
    result += js6
    result += js7
    result += js8
    result += js9
    result += js10
    result += js11
    result += js12
    result += js13
    result += js14
    result += js15
    result += js16
    result += js17
    result += js18
    result += js19
    result += js20
    result += js21
    result += js22
    result += js23

func join(slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice, js10 slice, js11 slice, js12 slice, js13 slice, js14 slice, js15 slice, js16 slice, js17 slice, js18 slice, js19 slice, js20 slice, js21 slice, js22 slice, js23 slice, js24 slice) slice
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength() + js10.getLength() + js11.getLength() + js12.getLength() + js13.getLength() + js14.getLength() + js15.getLength() + js16.getLength() + js17.getLength() + js18.getLength() + js19.getLength() + js20.getLength() + js21.getLength() + js22.getLength() + js23.getLength() + js24.getLength()
    result = #slice.dummy(length)
    if slice.string?()
        then result:setStringFlag()
    result += slice
    result += js1
    result += js2
    result += js3
    result += js4
    result += js5
    result += js6
    result += js7
    result += js8
    result += js9
    result += js10
    result += js11
    result += js12
    result += js13
    result += js14
    result += js15
    result += js16
    result += js17
    result += js18
    result += js19
    result += js20
    result += js21
    result += js22
    result += js23
    result += js24

func join(slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice, js10 slice, js11 slice, js12 slice, js13 slice, js14 slice, js15 slice, js16 slice, js17 slice, js18 slice, js19 slice, js20 slice, js21 slice, js22 slice, js23 slice, js24 slice, js25 slice) slice
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength() + js10.getLength() + js11.getLength() + js12.getLength() + js13.getLength() + js14.getLength() + js15.getLength() + js16.getLength() + js17.getLength() + js18.getLength() + js19.getLength() + js20.getLength() + js21.getLength() + js22.getLength() + js23.getLength() + js24.getLength() + js25.getLength()
    result = #slice.dummy(length)
    if slice.string?()
        then result:setStringFlag()
    result += slice
    result += js1
    result += js2
    result += js3
    result += js4
    result += js5
    result += js6
    result += js7
    result += js8
    result += js9
    result += js10
    result += js11
    result += js12
    result += js13
    result += js14
    result += js15
    result += js16
    result += js17
    result += js18
    result += js19
    result += js20
    result += js21
    result += js22
    result += js23
    result += js24
    result += js25

func join(slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice, js10 slice, js11 slice, js12 slice, js13 slice, js14 slice, js15 slice, js16 slice, js17 slice, js18 slice, js19 slice, js20 slice, js21 slice, js22 slice, js23 slice, js24 slice, js25 slice, js26 slice) slice
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength() + js10.getLength() + js11.getLength() + js12.getLength() + js13.getLength() + js14.getLength() + js15.getLength() + js16.getLength() + js17.getLength() + js18.getLength() + js19.getLength() + js20.getLength() + js21.getLength() + js22.getLength() + js23.getLength() + js24.getLength() + js25.getLength() + js26.getLength()
    result = #slice.dummy(length)
    if slice.string?()
        then result:setStringFlag()
    result += slice
    result += js1
    result += js2
    result += js3
    result += js4
    result += js5
    result += js6
    result += js7
    result += js8
    result += js9
    result += js10
    result += js11
    result += js12
    result += js13
    result += js14
    result += js15
    result += js16
    result += js17
    result += js18
    result += js19
    result += js20
    result += js21
    result += js22
    result += js23
    result += js24
    result += js25
    result += js26

func join(slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice, js10 slice, js11 slice, js12 slice, js13 slice, js14 slice, js15 slice, js16 slice, js17 slice, js18 slice, js19 slice, js20 slice, js21 slice, js22 slice, js23 slice, js24 slice, js25 slice, js26 slice, js27 slice) slice
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength() + js10.getLength() + js11.getLength() + js12.getLength() + js13.getLength() + js14.getLength() + js15.getLength() + js16.getLength() + js17.getLength() + js18.getLength() + js19.getLength() + js20.getLength() + js21.getLength() + js22.getLength() + js23.getLength() + js24.getLength() + js25.getLength() + js26.getLength() + js27.getLength()
    result = #slice.dummy(length)
    if slice.string?()
        then result:setStringFlag()
    result += slice
    result += js1
    result += js2
    result += js3
    result += js4
    result += js5
    result += js6
    result += js7
    result += js8
    result += js9
    result += js10
    result += js11
    result += js12
    result += js13
    result += js14
    result += js15
    result += js16
    result += js17
    result += js18
    result += js19
    result += js20
    result += js21
    result += js22
    result += js23
    result += js24
    result += js25
    result += js26
    result += js27

func join(slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice, js10 slice, js11 slice, js12 slice, js13 slice, js14 slice, js15 slice, js16 slice, js17 slice, js18 slice, js19 slice, js20 slice, js21 slice, js22 slice, js23 slice, js24 slice, js25 slice, js26 slice, js27 slice, js28 slice) slice
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength() + js10.getLength() + js11.getLength() + js12.getLength() + js13.getLength() + js14.getLength() + js15.getLength() + js16.getLength() + js17.getLength() + js18.getLength() + js19.getLength() + js20.getLength() + js21.getLength() + js22.getLength() + js23.getLength() + js24.getLength() + js25.getLength() + js26.getLength() + js27.getLength() + js28.getLength()
    result = #slice.dummy(length)
    if slice.string?()
        then result:setStringFlag()
    result += slice
    result += js1
    result += js2
    result += js3
    result += js4
    result += js5
    result += js6
    result += js7
    result += js8
    result += js9
    result += js10
    result += js11
    result += js12
    result += js13
    result += js14
    result += js15
    result += js16
    result += js17
    result += js18
    result += js19
    result += js20
    result += js21
    result += js22
    result += js23
    result += js24
    result += js25
    result += js26
    result += js27
    result += js28

func join(slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice, js10 slice, js11 slice, js12 slice, js13 slice, js14 slice, js15 slice, js16 slice, js17 slice, js18 slice, js19 slice, js20 slice, js21 slice, js22 slice, js23 slice, js24 slice, js25 slice, js26 slice, js27 slice, js28 slice, js29 slice) slice
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength() + js10.getLength() + js11.getLength() + js12.getLength() + js13.getLength() + js14.getLength() + js15.getLength() + js16.getLength() + js17.getLength() + js18.getLength() + js19.getLength() + js20.getLength() + js21.getLength() + js22.getLength() + js23.getLength() + js24.getLength() + js25.getLength() + js26.getLength() + js27.getLength() + js28.getLength() + js29.getLength()
    result = #slice.dummy(length)
    if slice.string?()
        then result:setStringFlag()
    result += slice
    result += js1
    result += js2
    result += js3
    result += js4
    result += js5
    result += js6
    result += js7
    result += js8
    result += js9
    result += js10
    result += js11
    result += js12
    result += js13
    result += js14
    result += js15
    result += js16
    result += js17
    result += js18
    result += js19
    result += js20
    result += js21
    result += js22
    result += js23
    result += js24
    result += js25
    result += js26
    result += js27
    result += js28
    result += js29

func join(slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice, js10 slice, js11 slice, js12 slice, js13 slice, js14 slice, js15 slice, js16 slice, js17 slice, js18 slice, js19 slice, js20 slice, js21 slice, js22 slice, js23 slice, js24 slice, js25 slice, js26 slice, js27 slice, js28 slice, js29 slice, js30 slice) slice
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength() + js10.getLength() + js11.getLength() + js12.getLength() + js13.getLength() + js14.getLength() + js15.getLength() + js16.getLength() + js17.getLength() + js18.getLength() + js19.getLength() + js20.getLength() + js21.getLength() + js22.getLength() + js23.getLength() + js24.getLength() + js25.getLength() + js26.getLength() + js27.getLength() + js28.getLength() + js29.getLength() + js30.getLength()
    result = #slice.dummy(length)
    if slice.string?()
        then result:setStringFlag()
    result += slice
    result += js1
    result += js2
    result += js3
    result += js4
    result += js5
    result += js6
    result += js7
    result += js8
    result += js9
    result += js10
    result += js11
    result += js12
    result += js13
    result += js14
    result += js15
    result += js16
    result += js17
    result += js18
    result += js19
    result += js20
    result += js21
    result += js22
    result += js23
    result += js24
    result += js25
    result += js26
    result += js27
    result += js28
    result += js29
    result += js30

func join(slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice, js10 slice, js11 slice, js12 slice, js13 slice, js14 slice, js15 slice, js16 slice, js17 slice, js18 slice, js19 slice, js20 slice, js21 slice, js22 slice, js23 slice, js24 slice, js25 slice, js26 slice, js27 slice, js28 slice, js29 slice, js30 slice, js31 slice) slice
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength() + js10.getLength() + js11.getLength() + js12.getLength() + js13.getLength() + js14.getLength() + js15.getLength() + js16.getLength() + js17.getLength() + js18.getLength() + js19.getLength() + js20.getLength() + js21.getLength() + js22.getLength() + js23.getLength() + js24.getLength() + js25.getLength() + js26.getLength() + js27.getLength() + js28.getLength() + js29.getLength() + js30.getLength() + js31.getLength()
    result = #slice.dummy(length)
    if slice.string?()
        then result:setStringFlag()
    result += slice
    result += js1
    result += js2
    result += js3
    result += js4
    result += js5
    result += js6
    result += js7
    result += js8
    result += js9
    result += js10
    result += js11
    result += js12
    result += js13
    result += js14
    result += js15
    result += js16
    result += js17
    result += js18
    result += js19
    result += js20
    result += js21
    result += js22
    result += js23
    result += js24
    result += js25
    result += js26
    result += js27
    result += js28
    result += js29
    result += js30
    result += js31

func join(slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice, js10 slice, js11 slice, js12 slice, js13 slice, js14 slice, js15 slice, js16 slice, js17 slice, js18 slice, js19 slice, js20 slice, js21 slice, js22 slice, js23 slice, js24 slice, js25 slice, js26 slice, js27 slice, js28 slice, js29 slice, js30 slice, js31 slice, js32 slice) slice
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength() + js10.getLength() + js11.getLength() + js12.getLength() + js13.getLength() + js14.getLength() + js15.getLength() + js16.getLength() + js17.getLength() + js18.getLength() + js19.getLength() + js20.getLength() + js21.getLength() + js22.getLength() + js23.getLength() + js24.getLength() + js25.getLength() + js26.getLength() + js27.getLength() + js28.getLength() + js29.getLength() + js30.getLength() + js31.getLength() + js32.getLength()
    result = #slice.dummy(length)
    if slice.string?()
        then result:setStringFlag()
    result += slice
    result += js1
    result += js2
    result += js3
    result += js4
    result += js5
    result += js6
    result += js7
    result += js8
    result += js9
    result += js10
    result += js11
    result += js12
    result += js13
    result += js14
    result += js15
    result += js16
    result += js17
    result += js18
    result += js19
    result += js20
    result += js21
    result += js22
    result += js23
    result += js24
    result += js25
    result += js26
    result += js27
    result += js28
    result += js29
    result += js30
    result += js31
    result += js32

proc join(:slice [_], js1 slice, js2 slice)
    length .= slice.getLength() + js1.getLength() + js2.getLength()
    if slice.use?() || slice.getCapacity() < length
        then
            newSlice := #slice.dummy(((length + length / 4) / 64 + 1) * 64)
            if slice.string?()
                then newSlice:setStringFlag()
            newSlice += slice
            slice = newSlice
    slice += js1
    slice += js2

proc join(:slice [_], js1 slice, js2 slice, js3 slice)
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength()
    if slice.use?() || slice.getCapacity() < length
        then
            newSlice := #slice.dummy(((length + length / 4) / 64 + 1) * 64)
            if slice.string?()
                then newSlice:setStringFlag()
            newSlice += slice
            slice = newSlice
    slice += js1
    slice += js2
    slice += js3

proc join(:slice [_], js1 slice, js2 slice, js3 slice, js4 slice)
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength()
    if slice.use?() || slice.getCapacity() < length
        then
            newSlice := #slice.dummy(((length + length / 4) / 64 + 1) * 64)
            if slice.string?()
                then newSlice:setStringFlag()
            newSlice += slice
            slice = newSlice
    slice += js1
    slice += js2
    slice += js3
    slice += js4

proc join(:slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice)
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength()
    if slice.use?() || slice.getCapacity() < length
        then
            newSlice := #slice.dummy(((length + length / 4) / 64 + 1) * 64)
            if slice.string?()
                then newSlice:setStringFlag()
            newSlice += slice
            slice = newSlice
    slice += js1
    slice += js2
    slice += js3
    slice += js4
    slice += js5

proc join(:slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice)
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength()
    if slice.use?() || slice.getCapacity() < length
        then
            newSlice := #slice.dummy(((length + length / 4) / 64 + 1) * 64)
            if slice.string?()
                then newSlice:setStringFlag()
            newSlice += slice
            slice = newSlice
    slice += js1
    slice += js2
    slice += js3
    slice += js4
    slice += js5
    slice += js6

proc join(:slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice)
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength()
    if slice.use?() || slice.getCapacity() < length
        then
            newSlice := #slice.dummy(((length + length / 4) / 64 + 1) * 64)
            if slice.string?()
                then newSlice:setStringFlag()
            newSlice += slice
            slice = newSlice
    slice += js1
    slice += js2
    slice += js3
    slice += js4
    slice += js5
    slice += js6
    slice += js7

proc join(:slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice)
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength()
    if slice.use?() || slice.getCapacity() < length
        then
            newSlice := #slice.dummy(((length + length / 4) / 64 + 1) * 64)
            if slice.string?()
                then newSlice:setStringFlag()
            newSlice += slice
            slice = newSlice
    slice += js1
    slice += js2
    slice += js3
    slice += js4
    slice += js5
    slice += js6
    slice += js7
    slice += js8

proc join(:slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice)
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength()
    if slice.use?() || slice.getCapacity() < length
        then
            newSlice := #slice.dummy(((length + length / 4) / 64 + 1) * 64)
            if slice.string?()
                then newSlice:setStringFlag()
            newSlice += slice
            slice = newSlice
    slice += js1
    slice += js2
    slice += js3
    slice += js4
    slice += js5
    slice += js6
    slice += js7
    slice += js8
    slice += js9

proc join(:slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice, js10 slice)
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength() + js10.getLength()
    if slice.use?() || slice.getCapacity() < length
        then
            newSlice := #slice.dummy(((length + length / 4) / 64 + 1) * 64)
            if slice.string?()
                then newSlice:setStringFlag()
            newSlice += slice
            slice = newSlice
    slice += js1
    slice += js2
    slice += js3
    slice += js4
    slice += js5
    slice += js6
    slice += js7
    slice += js8
    slice += js9
    slice += js10

proc join(:slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice, js10 slice, js11 slice)
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength() + js10.getLength() + js11.getLength()
    if slice.use?() || slice.getCapacity() < length
        then
            newSlice := #slice.dummy(((length + length / 4) / 64 + 1) * 64)
            if slice.string?()
                then newSlice:setStringFlag()
            newSlice += slice
            slice = newSlice
    slice += js1
    slice += js2
    slice += js3
    slice += js4
    slice += js5
    slice += js6
    slice += js7
    slice += js8
    slice += js9
    slice += js10
    slice += js11

proc join(:slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice, js10 slice, js11 slice, js12 slice)
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength() + js10.getLength() + js11.getLength() + js12.getLength()
    if slice.use?() || slice.getCapacity() < length
        then
            newSlice := #slice.dummy(((length + length / 4) / 64 + 1) * 64)
            if slice.string?()
                then newSlice:setStringFlag()
            newSlice += slice
            slice = newSlice
    slice += js1
    slice += js2
    slice += js3
    slice += js4
    slice += js5
    slice += js6
    slice += js7
    slice += js8
    slice += js9
    slice += js10
    slice += js11
    slice += js12

proc join(:slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice, js10 slice, js11 slice, js12 slice, js13 slice)
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength() + js10.getLength() + js11.getLength() + js12.getLength() + js13.getLength()
    if slice.use?() || slice.getCapacity() < length
        then
            newSlice := #slice.dummy(((length + length / 4) / 64 + 1) * 64)
            if slice.string?()
                then newSlice:setStringFlag()
            newSlice += slice
            slice = newSlice
    slice += js1
    slice += js2
    slice += js3
    slice += js4
    slice += js5
    slice += js6
    slice += js7
    slice += js8
    slice += js9
    slice += js10
    slice += js11
    slice += js12
    slice += js13

proc join(:slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice, js10 slice, js11 slice, js12 slice, js13 slice, js14 slice)
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength() + js10.getLength() + js11.getLength() + js12.getLength() + js13.getLength() + js14.getLength()
    if slice.use?() || slice.getCapacity() < length
        then
            newSlice := #slice.dummy(((length + length / 4) / 64 + 1) * 64)
            if slice.string?()
                then newSlice:setStringFlag()
            newSlice += slice
            slice = newSlice
    slice += js1
    slice += js2
    slice += js3
    slice += js4
    slice += js5
    slice += js6
    slice += js7
    slice += js8
    slice += js9
    slice += js10
    slice += js11
    slice += js12
    slice += js13
    slice += js14

proc join(:slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice, js10 slice, js11 slice, js12 slice, js13 slice, js14 slice, js15 slice)
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength() + js10.getLength() + js11.getLength() + js12.getLength() + js13.getLength() + js14.getLength() + js15.getLength()
    if slice.use?() || slice.getCapacity() < length
        then
            newSlice := #slice.dummy(((length + length / 4) / 64 + 1) * 64)
            if slice.string?()
                then newSlice:setStringFlag()
            newSlice += slice
            slice = newSlice
    slice += js1
    slice += js2
    slice += js3
    slice += js4
    slice += js5
    slice += js6
    slice += js7
    slice += js8
    slice += js9
    slice += js10
    slice += js11
    slice += js12
    slice += js13
    slice += js14
    slice += js15

proc join(:slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice, js10 slice, js11 slice, js12 slice, js13 slice, js14 slice, js15 slice, js16 slice)
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength() + js10.getLength() + js11.getLength() + js12.getLength() + js13.getLength() + js14.getLength() + js15.getLength() + js16.getLength()
    if slice.use?() || slice.getCapacity() < length
        then
            newSlice := #slice.dummy(((length + length / 4) / 64 + 1) * 64)
            if slice.string?()
                then newSlice:setStringFlag()
            newSlice += slice
            slice = newSlice
    slice += js1
    slice += js2
    slice += js3
    slice += js4
    slice += js5
    slice += js6
    slice += js7
    slice += js8
    slice += js9
    slice += js10
    slice += js11
    slice += js12
    slice += js13
    slice += js14
    slice += js15
    slice += js16

proc join(:slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice, js10 slice, js11 slice, js12 slice, js13 slice, js14 slice, js15 slice, js16 slice, js17 slice)
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength() + js10.getLength() + js11.getLength() + js12.getLength() + js13.getLength() + js14.getLength() + js15.getLength() + js16.getLength() + js17.getLength()
    if slice.use?() || slice.getCapacity() < length
        then
            newSlice := #slice.dummy(((length + length / 4) / 64 + 1) * 64)
            if slice.string?()
                then newSlice:setStringFlag()
            newSlice += slice
            slice = newSlice
    slice += js1
    slice += js2
    slice += js3
    slice += js4
    slice += js5
    slice += js6
    slice += js7
    slice += js8
    slice += js9
    slice += js10
    slice += js11
    slice += js12
    slice += js13
    slice += js14
    slice += js15
    slice += js16
    slice += js17

proc join(:slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice, js10 slice, js11 slice, js12 slice, js13 slice, js14 slice, js15 slice, js16 slice, js17 slice, js18 slice)
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength() + js10.getLength() + js11.getLength() + js12.getLength() + js13.getLength() + js14.getLength() + js15.getLength() + js16.getLength() + js17.getLength() + js18.getLength()
    if slice.use?() || slice.getCapacity() < length
        then
            newSlice := #slice.dummy(((length + length / 4) / 64 + 1) * 64)
            if slice.string?()
                then newSlice:setStringFlag()
            newSlice += slice
            slice = newSlice
    slice += js1
    slice += js2
    slice += js3
    slice += js4
    slice += js5
    slice += js6
    slice += js7
    slice += js8
    slice += js9
    slice += js10
    slice += js11
    slice += js12
    slice += js13
    slice += js14
    slice += js15
    slice += js16
    slice += js17
    slice += js18

proc join(:slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice, js10 slice, js11 slice, js12 slice, js13 slice, js14 slice, js15 slice, js16 slice, js17 slice, js18 slice, js19 slice)
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength() + js10.getLength() + js11.getLength() + js12.getLength() + js13.getLength() + js14.getLength() + js15.getLength() + js16.getLength() + js17.getLength() + js18.getLength() + js19.getLength()
    if slice.use?() || slice.getCapacity() < length
        then
            newSlice := #slice.dummy(((length + length / 4) / 64 + 1) * 64)
            if slice.string?()
                then newSlice:setStringFlag()
            newSlice += slice
            slice = newSlice
    slice += js1
    slice += js2
    slice += js3
    slice += js4
    slice += js5
    slice += js6
    slice += js7
    slice += js8
    slice += js9
    slice += js10
    slice += js11
    slice += js12
    slice += js13
    slice += js14
    slice += js15
    slice += js16
    slice += js17
    slice += js18
    slice += js19

proc join(:slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice, js10 slice, js11 slice, js12 slice, js13 slice, js14 slice, js15 slice, js16 slice, js17 slice, js18 slice, js19 slice, js20 slice)
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength() + js10.getLength() + js11.getLength() + js12.getLength() + js13.getLength() + js14.getLength() + js15.getLength() + js16.getLength() + js17.getLength() + js18.getLength() + js19.getLength() + js20.getLength()
    if slice.use?() || slice.getCapacity() < length
        then
            newSlice := #slice.dummy(((length + length / 4) / 64 + 1) * 64)
            if slice.string?()
                then newSlice:setStringFlag()
            newSlice += slice
            slice = newSlice
    slice += js1
    slice += js2
    slice += js3
    slice += js4
    slice += js5
    slice += js6
    slice += js7
    slice += js8
    slice += js9
    slice += js10
    slice += js11
    slice += js12
    slice += js13
    slice += js14
    slice += js15
    slice += js16
    slice += js17
    slice += js18
    slice += js19
    slice += js20

proc join(:slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice, js10 slice, js11 slice, js12 slice, js13 slice, js14 slice, js15 slice, js16 slice, js17 slice, js18 slice, js19 slice, js20 slice, js21 slice)
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength() + js10.getLength() + js11.getLength() + js12.getLength() + js13.getLength() + js14.getLength() + js15.getLength() + js16.getLength() + js17.getLength() + js18.getLength() + js19.getLength() + js20.getLength() + js21.getLength()
    if slice.use?() || slice.getCapacity() < length
        then
            newSlice := #slice.dummy(((length + length / 4) / 64 + 1) * 64)
            if slice.string?()
                then newSlice:setStringFlag()
            newSlice += slice
            slice = newSlice
    slice += js1
    slice += js2
    slice += js3
    slice += js4
    slice += js5
    slice += js6
    slice += js7
    slice += js8
    slice += js9
    slice += js10
    slice += js11
    slice += js12
    slice += js13
    slice += js14
    slice += js15
    slice += js16
    slice += js17
    slice += js18
    slice += js19
    slice += js20
    slice += js21

proc join(:slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice, js10 slice, js11 slice, js12 slice, js13 slice, js14 slice, js15 slice, js16 slice, js17 slice, js18 slice, js19 slice, js20 slice, js21 slice, js22 slice)
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength() + js10.getLength() + js11.getLength() + js12.getLength() + js13.getLength() + js14.getLength() + js15.getLength() + js16.getLength() + js17.getLength() + js18.getLength() + js19.getLength() + js20.getLength() + js21.getLength() + js22.getLength()
    if slice.use?() || slice.getCapacity() < length
        then
            newSlice := #slice.dummy(((length + length / 4) / 64 + 1) * 64)
            if slice.string?()
                then newSlice:setStringFlag()
            newSlice += slice
            slice = newSlice
    slice += js1
    slice += js2
    slice += js3
    slice += js4
    slice += js5
    slice += js6
    slice += js7
    slice += js8
    slice += js9
    slice += js10
    slice += js11
    slice += js12
    slice += js13
    slice += js14
    slice += js15
    slice += js16
    slice += js17
    slice += js18
    slice += js19
    slice += js20
    slice += js21
    slice += js22

proc join(:slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice, js10 slice, js11 slice, js12 slice, js13 slice, js14 slice, js15 slice, js16 slice, js17 slice, js18 slice, js19 slice, js20 slice, js21 slice, js22 slice, js23 slice)
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength() + js10.getLength() + js11.getLength() + js12.getLength() + js13.getLength() + js14.getLength() + js15.getLength() + js16.getLength() + js17.getLength() + js18.getLength() + js19.getLength() + js20.getLength() + js21.getLength() + js22.getLength() + js23.getLength()
    if slice.use?() || slice.getCapacity() < length
        then
            newSlice := #slice.dummy(((length + length / 4) / 64 + 1) * 64)
            if slice.string?()
                then newSlice:setStringFlag()
            newSlice += slice
            slice = newSlice
    slice += js1
    slice += js2
    slice += js3
    slice += js4
    slice += js5
    slice += js6
    slice += js7
    slice += js8
    slice += js9
    slice += js10
    slice += js11
    slice += js12
    slice += js13
    slice += js14
    slice += js15
    slice += js16
    slice += js17
    slice += js18
    slice += js19
    slice += js20
    slice += js21
    slice += js22
    slice += js23

proc join(:slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice, js10 slice, js11 slice, js12 slice, js13 slice, js14 slice, js15 slice, js16 slice, js17 slice, js18 slice, js19 slice, js20 slice, js21 slice, js22 slice, js23 slice, js24 slice)
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength() + js10.getLength() + js11.getLength() + js12.getLength() + js13.getLength() + js14.getLength() + js15.getLength() + js16.getLength() + js17.getLength() + js18.getLength() + js19.getLength() + js20.getLength() + js21.getLength() + js22.getLength() + js23.getLength() + js24.getLength()
    if slice.use?() || slice.getCapacity() < length
        then
            newSlice := #slice.dummy(((length + length / 4) / 64 + 1) * 64)
            if slice.string?()
                then newSlice:setStringFlag()
            newSlice += slice
            slice = newSlice
    slice += js1
    slice += js2
    slice += js3
    slice += js4
    slice += js5
    slice += js6
    slice += js7
    slice += js8
    slice += js9
    slice += js10
    slice += js11
    slice += js12
    slice += js13
    slice += js14
    slice += js15
    slice += js16
    slice += js17
    slice += js18
    slice += js19
    slice += js20
    slice += js21
    slice += js22
    slice += js23
    slice += js24

proc join(:slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice, js10 slice, js11 slice, js12 slice, js13 slice, js14 slice, js15 slice, js16 slice, js17 slice, js18 slice, js19 slice, js20 slice, js21 slice, js22 slice, js23 slice, js24 slice, js25 slice)
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength() + js10.getLength() + js11.getLength() + js12.getLength() + js13.getLength() + js14.getLength() + js15.getLength() + js16.getLength() + js17.getLength() + js18.getLength() + js19.getLength() + js20.getLength() + js21.getLength() + js22.getLength() + js23.getLength() + js24.getLength() + js25.getLength()
    if slice.use?() || slice.getCapacity() < length
        then
            newSlice := #slice.dummy(((length + length / 4) / 64 + 1) * 64)
            if slice.string?()
                then newSlice:setStringFlag()
            newSlice += slice
            slice = newSlice
    slice += js1
    slice += js2
    slice += js3
    slice += js4
    slice += js5
    slice += js6
    slice += js7
    slice += js8
    slice += js9
    slice += js10
    slice += js11
    slice += js12
    slice += js13
    slice += js14
    slice += js15
    slice += js16
    slice += js17
    slice += js18
    slice += js19
    slice += js20
    slice += js21
    slice += js22
    slice += js23
    slice += js24
    slice += js25

proc join(:slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice, js10 slice, js11 slice, js12 slice, js13 slice, js14 slice, js15 slice, js16 slice, js17 slice, js18 slice, js19 slice, js20 slice, js21 slice, js22 slice, js23 slice, js24 slice, js25 slice, js26 slice)
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength() + js10.getLength() + js11.getLength() + js12.getLength() + js13.getLength() + js14.getLength() + js15.getLength() + js16.getLength() + js17.getLength() + js18.getLength() + js19.getLength() + js20.getLength() + js21.getLength() + js22.getLength() + js23.getLength() + js24.getLength() + js25.getLength() + js26.getLength()
    if slice.use?() || slice.getCapacity() < length
        then
            newSlice := #slice.dummy(((length + length / 4) / 64 + 1) * 64)
            if slice.string?()
                then newSlice:setStringFlag()
            newSlice += slice
            slice = newSlice
    slice += js1
    slice += js2
    slice += js3
    slice += js4
    slice += js5
    slice += js6
    slice += js7
    slice += js8
    slice += js9
    slice += js10
    slice += js11
    slice += js12
    slice += js13
    slice += js14
    slice += js15
    slice += js16
    slice += js17
    slice += js18
    slice += js19
    slice += js20
    slice += js21
    slice += js22
    slice += js23
    slice += js24
    slice += js25
    slice += js26

proc join(:slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice, js10 slice, js11 slice, js12 slice, js13 slice, js14 slice, js15 slice, js16 slice, js17 slice, js18 slice, js19 slice, js20 slice, js21 slice, js22 slice, js23 slice, js24 slice, js25 slice, js26 slice, js27 slice)
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength() + js10.getLength() + js11.getLength() + js12.getLength() + js13.getLength() + js14.getLength() + js15.getLength() + js16.getLength() + js17.getLength() + js18.getLength() + js19.getLength() + js20.getLength() + js21.getLength() + js22.getLength() + js23.getLength() + js24.getLength() + js25.getLength() + js26.getLength() + js27.getLength()
    if slice.use?() || slice.getCapacity() < length
        then
            newSlice := #slice.dummy(((length + length / 4) / 64 + 1) * 64)
            if slice.string?()
                then newSlice:setStringFlag()
            newSlice += slice
            slice = newSlice
    slice += js1
    slice += js2
    slice += js3
    slice += js4
    slice += js5
    slice += js6
    slice += js7
    slice += js8
    slice += js9
    slice += js10
    slice += js11
    slice += js12
    slice += js13
    slice += js14
    slice += js15
    slice += js16
    slice += js17
    slice += js18
    slice += js19
    slice += js20
    slice += js21
    slice += js22
    slice += js23
    slice += js24
    slice += js25
    slice += js26
    slice += js27

proc join(:slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice, js10 slice, js11 slice, js12 slice, js13 slice, js14 slice, js15 slice, js16 slice, js17 slice, js18 slice, js19 slice, js20 slice, js21 slice, js22 slice, js23 slice, js24 slice, js25 slice, js26 slice, js27 slice, js28 slice)
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength() + js10.getLength() + js11.getLength() + js12.getLength() + js13.getLength() + js14.getLength() + js15.getLength() + js16.getLength() + js17.getLength() + js18.getLength() + js19.getLength() + js20.getLength() + js21.getLength() + js22.getLength() + js23.getLength() + js24.getLength() + js25.getLength() + js26.getLength() + js27.getLength() + js28.getLength()
    if slice.use?() || slice.getCapacity() < length
        then
            newSlice := #slice.dummy(((length + length / 4) / 64 + 1) * 64)
            if slice.string?()
                then newSlice:setStringFlag()
            newSlice += slice
            slice = newSlice
    slice += js1
    slice += js2
    slice += js3
    slice += js4
    slice += js5
    slice += js6
    slice += js7
    slice += js8
    slice += js9
    slice += js10
    slice += js11
    slice += js12
    slice += js13
    slice += js14
    slice += js15
    slice += js16
    slice += js17
    slice += js18
    slice += js19
    slice += js20
    slice += js21
    slice += js22
    slice += js23
    slice += js24
    slice += js25
    slice += js26
    slice += js27
    slice += js28

proc join(:slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice, js10 slice, js11 slice, js12 slice, js13 slice, js14 slice, js15 slice, js16 slice, js17 slice, js18 slice, js19 slice, js20 slice, js21 slice, js22 slice, js23 slice, js24 slice, js25 slice, js26 slice, js27 slice, js28 slice, js29 slice)
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength() + js10.getLength() + js11.getLength() + js12.getLength() + js13.getLength() + js14.getLength() + js15.getLength() + js16.getLength() + js17.getLength() + js18.getLength() + js19.getLength() + js20.getLength() + js21.getLength() + js22.getLength() + js23.getLength() + js24.getLength() + js25.getLength() + js26.getLength() + js27.getLength() + js28.getLength() + js29.getLength()
    if slice.use?() || slice.getCapacity() < length
        then
            newSlice := #slice.dummy(((length + length / 4) / 64 + 1) * 64)
            if slice.string?()
                then newSlice:setStringFlag()
            newSlice += slice
            slice = newSlice
    slice += js1
    slice += js2
    slice += js3
    slice += js4
    slice += js5
    slice += js6
    slice += js7
    slice += js8
    slice += js9
    slice += js10
    slice += js11
    slice += js12
    slice += js13
    slice += js14
    slice += js15
    slice += js16
    slice += js17
    slice += js18
    slice += js19
    slice += js20
    slice += js21
    slice += js22
    slice += js23
    slice += js24
    slice += js25
    slice += js26
    slice += js27
    slice += js28
    slice += js29

proc join(:slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice, js10 slice, js11 slice, js12 slice, js13 slice, js14 slice, js15 slice, js16 slice, js17 slice, js18 slice, js19 slice, js20 slice, js21 slice, js22 slice, js23 slice, js24 slice, js25 slice, js26 slice, js27 slice, js28 slice, js29 slice, js30 slice)
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength() + js10.getLength() + js11.getLength() + js12.getLength() + js13.getLength() + js14.getLength() + js15.getLength() + js16.getLength() + js17.getLength() + js18.getLength() + js19.getLength() + js20.getLength() + js21.getLength() + js22.getLength() + js23.getLength() + js24.getLength() + js25.getLength() + js26.getLength() + js27.getLength() + js28.getLength() + js29.getLength() + js30.getLength()
    if slice.use?() || slice.getCapacity() < length
        then
            newSlice := #slice.dummy(((length + length / 4) / 64 + 1) * 64)
            if slice.string?()
                then newSlice:setStringFlag()
            newSlice += slice
            slice = newSlice
    slice += js1
    slice += js2
    slice += js3
    slice += js4
    slice += js5
    slice += js6
    slice += js7
    slice += js8
    slice += js9
    slice += js10
    slice += js11
    slice += js12
    slice += js13
    slice += js14
    slice += js15
    slice += js16
    slice += js17
    slice += js18
    slice += js19
    slice += js20
    slice += js21
    slice += js22
    slice += js23
    slice += js24
    slice += js25
    slice += js26
    slice += js27
    slice += js28
    slice += js29
    slice += js30

proc join(:slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice, js10 slice, js11 slice, js12 slice, js13 slice, js14 slice, js15 slice, js16 slice, js17 slice, js18 slice, js19 slice, js20 slice, js21 slice, js22 slice, js23 slice, js24 slice, js25 slice, js26 slice, js27 slice, js28 slice, js29 slice, js30 slice, js31 slice)
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength() + js10.getLength() + js11.getLength() + js12.getLength() + js13.getLength() + js14.getLength() + js15.getLength() + js16.getLength() + js17.getLength() + js18.getLength() + js19.getLength() + js20.getLength() + js21.getLength() + js22.getLength() + js23.getLength() + js24.getLength() + js25.getLength() + js26.getLength() + js27.getLength() + js28.getLength() + js29.getLength() + js30.getLength() + js31.getLength()
    if slice.use?() || slice.getCapacity() < length
        then
            newSlice := #slice.dummy(((length + length / 4) / 64 + 1) * 64)
            if slice.string?()
                then newSlice:setStringFlag()
            newSlice += slice
            slice = newSlice
    slice += js1
    slice += js2
    slice += js3
    slice += js4
    slice += js5
    slice += js6
    slice += js7
    slice += js8
    slice += js9
    slice += js10
    slice += js11
    slice += js12
    slice += js13
    slice += js14
    slice += js15
    slice += js16
    slice += js17
    slice += js18
    slice += js19
    slice += js20
    slice += js21
    slice += js22
    slice += js23
    slice += js24
    slice += js25
    slice += js26
    slice += js27
    slice += js28
    slice += js29
    slice += js30
    slice += js31

proc join(:slice [_], js1 slice, js2 slice, js3 slice, js4 slice, js5 slice, js6 slice, js7 slice, js8 slice, js9 slice, js10 slice, js11 slice, js12 slice, js13 slice, js14 slice, js15 slice, js16 slice, js17 slice, js18 slice, js19 slice, js20 slice, js21 slice, js22 slice, js23 slice, js24 slice, js25 slice, js26 slice, js27 slice, js28 slice, js29 slice, js30 slice, js31 slice, js32 slice)
    length .= slice.getLength() + js1.getLength() + js2.getLength() + js3.getLength() + js4.getLength() + js5.getLength() + js6.getLength() + js7.getLength() + js8.getLength() + js9.getLength() + js10.getLength() + js11.getLength() + js12.getLength() + js13.getLength() + js14.getLength() + js15.getLength() + js16.getLength() + js17.getLength() + js18.getLength() + js19.getLength() + js20.getLength() + js21.getLength() + js22.getLength() + js23.getLength() + js24.getLength() + js25.getLength() + js26.getLength() + js27.getLength() + js28.getLength() + js29.getLength() + js30.getLength() + js31.getLength() + js32.getLength()
    if slice.use?() || slice.getCapacity() < length
        then
            newSlice := #slice.dummy(((length + length / 4) / 64 + 1) * 64)
            if slice.string?()
                then newSlice:setStringFlag()
            newSlice += slice
            slice = newSlice
    slice += js1
    slice += js2
    slice += js3
    slice += js4
    slice += js5
    slice += js6
    slice += js7
    slice += js8
    slice += js9
    slice += js10
    slice += js11
    slice += js12
    slice += js13
    slice += js14
    slice += js15
    slice += js16
    slice += js17
    slice += js18
    slice += js19
    slice += js20
    slice += js21
    slice += js22
    slice += js23
    slice += js24
    slice += js25
    slice += js26
    slice += js27
    slice += js28
    slice += js29
    slice += js30
    slice += js31
    slice += js32

func less(slice1 [_], slice2 slice1) Bool
    attributes
        alwaysInline
    rules
        final = slice1 > Ordered
    if minLength .= slice1.getLength().min(slice2.getLength()); minLength != 0
        then for index := 0; index < minLength; index++
            item1 .= slice1[index]
            item2 .= slice2[index]
            mif
                item1 < item2
                    return true
                item2 < item1
                    return false
    result = slice1.getLength() < slice2.getLength()

func lessOrEqual(slice1 [_], slice2 slice1) Bool
    attributes
        alwaysInline
    rules
        final = slice1 > Ordered
    if minLength .= slice1.getLength().min(slice2.getLength()); minLength != 0
        then for index := 0; index < minLength; index++
            item1 .= slice1[index]
            item2 .= slice2[index]
            mif
                item1 < item2
                    return true
                item2 < item1
                    return false
    result = slice1.getLength() <= slice2.getLength()

func look(slice [_], lookFor slice[0]) Box(UInt64)
    attributes
        alwaysInline
    rules
        final = slice > Equal
    parse index, item <- slice
        if item == lookFor
            then
                result:put(index)
                break

func look(slice [_], lookFor VAList(slice[0])) Box(Pair(slice[0], UInt64))
    attributes
        alwaysInline
    rules
        final = slice > Equal
    flag debug is set?
        then debugMessage(lookFor.getLength() == UInt8, "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - there is nothing to look for.")
    parse sliceIndex, sliceItem <- slice
        parse _, lookForItem <- lookFor
            if sliceItem == lookForItem
                then
                    result:put(Pair(slice[0], UInt64).create(lookForItem, sliceIndex))
                    return

func look(slice [_], lookFor slice) Box(UInt64)
    attributes
        alwaysInline
    rules
        final = slice > Equal
    flag debug is set?
        then debugMessage(lookFor.getLength() == 0, "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - there is nothing to look for.")
    mutSlice := slice
    firstItem .= lookFor[0]
    resultIndex := 0
    for mutSlice.getLength() >= lookFor.getLength()
        firstItemIndex .= mutSlice.look(firstItem)
        if firstItemIndex.empty?()
            then break
        resultIndex += firstItemIndex[]
        mutSlice = mutSlice.getAllExceptFirstN(firstItemIndex[])
        if mutSlice.hasPrefix?(lookFor)
            then
                result:put(resultIndex)
                break
            else
                resultIndex++
                mutSlice = mutSlice.getAllExceptFirst()

func look(slice [_], lookFor VAList(slice)) Box(Pair(slice, UInt64))
    attributes
        alwaysInline
    rules
        final = slice > Equal
    flag debug is set?
        then debugMessage(lookFor.getLength() == UInt8, "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - there is nothing to look for.")
    mutSlice := slice
    firstsItems := VAList(slice[0])
    enslave(firstsItems)
    listLength .= lookFor.getLength()
    C
        firstsItems_.length = listLength_;
    minLength := UInt64.maxValue()
    parse index, item <- lookFor
        flag debug is set?
            then debugMessage(item.getLength() == 0, "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - there is nothing to count.")
        minLength = minLength.min(item.getLength())
        C
            firstsItems_.items[index_] = item_.items[0];
    resultIndex := 0
    for mutSlice.getLength() >= minLength
        firstItemAndIndex .= mutSlice.look(firstsItems)
        if firstItemAndIndex.empty?()
            then break
        resultIndex += firstItemAndIndex[].second
        mutSlice = mutSlice.getAllExceptFirstN(firstItemAndIndex[].second)
        parse _, item <- lookFor
            if mutSlice.hasPrefix?(item)
                then
                    result:put(Pair(slice, UInt64).create(item, resultIndex))
                    return
        mutSlice = mutSlice.getAllExceptFirst()

func lookAll(slice [_], lookFor slice[0]) [UInt64]
    attributes
        alwaysInline
    rules
        final = slice > Equal
    parse index, item <- slice
        if item == lookFor
            then result += index

func lookAll(slice [_], lookFor VAList(slice[0])) [Pair(slice[0], UInt64)]
    attributes
        alwaysInline
    rules
        final = slice > Equal
    flag debug is set?
        then debugMessage(lookFor.getLength() == UInt8, "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - there is nothing to look for.")
    parse sliceIndex, sliceItem <- slice
        parse _, lookForItem <- lookFor
            if sliceItem == lookForItem
                then
                    result += Pair(slice[0], UInt64).create(lookForItem, sliceIndex)
                    break

func lookAll(slice [_], lookFor slice) [UInt64]
    attributes
        alwaysInline
    rules
        final = slice > Equal
    flag debug is set?
        then debugMessage(lookFor.getLength() == 0, "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - there is nothing to look for.")
    mutSlice := slice
    firstItem .= lookFor[0]
    offset := 0
    for mutSlice.getLength() >= lookFor.getLength()
        firstItemIndex .= mutSlice.look(firstItem)
        if firstItemIndex.empty?()
            then break
        mutSlice = mutSlice.getAllExceptFirstN(firstItemIndex[])
        offset += firstItemIndex[]
        countOfDeletingItems := 1
        if mutSlice.hasPrefix?(lookFor)
            then
                result += offset
                countOfDeletingItems = lookFor.getLength()
        offset += countOfDeletingItems
        mutSlice = mutSlice.getAllExceptFirstN(countOfDeletingItems)

func lookAll(slice [_], lookFor VAList(slice)) [Pair(slice, UInt64)]
    attributes
        alwaysInline
    rules
        final = slice > Equal
    flag debug is set?
        then debugMessage(lookFor.getLength() == UInt8, "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - there is nothing to look for.")
    mutSlice := slice
    firstsItems := VAList(slice[0])
    enslave(firstsItems)
    listLength .= lookFor.getLength()
    C
        firstsItems_.length = listLength_;
    minLength := UInt64.maxValue()
    parse index, item <- lookFor
        flag debug is set?
            then debugMessage(item.getLength() == 0, "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - there is nothing to count.")
        minLength = minLength.min(item.getLength())
        C
            firstsItems_.items[index_] = item_.items[0];
    offset := 0
    for mutSlice.getLength() >= minLength
        firstItemAndIndex .= mutSlice.look(firstsItems)
        if firstItemAndIndex.empty?()
            then break
        mutSlice = mutSlice.getAllExceptFirstN(firstItemAndIndex[].second)
        offset += firstItemAndIndex[].second
        countOfDeletingItems := 1
        parse _, item <- lookFor
            if mutSlice.hasPrefix?(item)
                then
                    result += Pair(slice, UInt64).create(item, offset)
                    countOfDeletingItems = item.getLength()
                    break
        offset += countOfDeletingItems
        mutSlice = mutSlice.getAllExceptFirstN(countOfDeletingItems)

func lookFromAtoB(slice [_], a > BasicUnsignedInteger, b > BasicUnsignedInteger, lookFor slice[0]) Box(UInt64)
    attributes
        alwaysInline
    rules
        final = slice > Equal
    result = slice.getSlice(a, b).look(lookFor)
    if result.item?()
        then result:put(result[] + a.convertTo(UInt64))

func lookFromAtoB(slice [_], a > BasicUnsignedInteger, b > BasicUnsignedInteger, lookFor VAList(slice[0])) Box(Pair(slice[0], UInt64))
    attributes
        alwaysInline
    rules
        final = slice > Equal
    result = slice.getSlice(a, b).look(lookFor)
    if result.item?()
        then result:put(Pair(slice[0], UInt64).create(result[].first, result[].second + a.convertTo(UInt64)))

func lookFromAtoB(slice [_], a > BasicUnsignedInteger, b > BasicUnsignedInteger, lookFor slice) Box(UInt64)
    attributes
        alwaysInline
    rules
        final = slice > Equal
    result = slice.getSlice(a, b).look(lookFor)
    if result.item?()
        then result:put(result[] + a.convertTo(UInt64))

func lookFromAtoB(slice [_], a > BasicUnsignedInteger, b > BasicUnsignedInteger, lookFor VAList(slice)) Box(Pair(slice, UInt64))
    attributes
        alwaysInline
    rules
        final = slice > Equal
    result = slice.getSlice(a, b).look(lookFor)
    if result.item?()
        then result:put(Pair(slice, UInt64).create(result[].first, result[].second + a.convertTo(UInt64)))

func lookLast(slice [_], lookFor slice[0]) Box(UInt64)
    attributes
        alwaysInline
    rules
        final = slice > Equal
    for index := slice.getLength() - 1; index != UInt64.maxValue(); index--
        if slice[index] == lookFor
            then
                result:put(index)
                break

func lookLast(slice [_], lookFor VAList(slice[0])) Box(Pair(slice[0], UInt64))
    attributes
        alwaysInline
    rules
        final = slice > Equal
    flag debug is set?
        then debugMessage(lookFor.getLength() == UInt8, "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - there is nothing to look for.")
    for sliceIndex := slice.getLength() - 1; sliceIndex != UInt64.maxValue(); sliceIndex--
        parse _, lookForItem <- lookFor
            if slice[sliceIndex] == lookForItem
                then
                    result:put(Pair(slice[0], UInt64).create(lookForItem, sliceIndex))
                    return

func lookLast(slice [_], lookFor slice) Box(UInt64)
    attributes
        alwaysInline
    rules
        final = slice > Equal
    flag debug is set?
        then debugMessage(lookFor.getLength() == 0, "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - there is nothing to look for.")
    mutSlice := slice
    firstItem .= lookFor[0]
    resultIndex := 0
    for mutSlice.getLength() >= lookFor.getLength()
        if result = mutSlice.lookLast(firstItem); result.empty?()
            then break
        if slice.getAllExceptFirstN(result[]).hasPrefix?(lookFor)
            then break
            else
                mutSlice = slice.getFirstN(result[])
                result = Box(UInt64)

func lookLast(slice [_], lookFor VAList(slice)) Box(Pair(slice, UInt64))
    attributes
        alwaysInline
    rules
        final = slice > Equal
    flag debug is set?
        then debugMessage(lookFor.getLength() == UInt8, "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - there is nothing to look for.")
    mutSlice := slice
    firstsItems := VAList(slice[0])
    enslave(firstsItems)
    listLength .= lookFor.getLength()
    C
        firstsItems_.length = listLength_;
    minLength := UInt64.maxValue()
    parse index, item <- lookFor
        flag debug is set?
            then debugMessage(item.getLength() == 0, "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - there is nothing to count.")
        minLength = minLength.min(item.getLength())
        C
            firstsItems_.items[index_] = item_.items[0];
    resultIndex := 0
    for mutSlice.getLength() >= minLength
        lastItemAndIndex .= mutSlice.lookLast(firstsItems)
        if lastItemAndIndex.empty?()
            then break
        lastPart .= slice.getAllExceptFirstN(lastItemAndIndex[].second)
        parse _, item <- lookFor
            if lastPart.hasPrefix?(item)
                then
                    result:put(Pair(slice, UInt64).create(item, lastItemAndIndex[].second))
                    return
        mutSlice = mutSlice.getFirstN(lastItemAndIndex[].second)

func lookLastFromAtoB(slice [_], a > BasicUnsignedInteger, b > BasicUnsignedInteger, lookFor slice[0]) Box(UInt64)
    attributes
        alwaysInline
    rules
        final = slice > Equal
    result = slice.getSlice(a, b).lookLast(lookFor)
    if result.item?()
        then result:put(result[] + a.convertTo(UInt64))

func lookLastFromAtoB(slice [_], a > BasicUnsignedInteger, b > BasicUnsignedInteger, lookFor VAList(slice[0])) Box(Pair(slice[0], UInt64))
    attributes
        alwaysInline
    rules
        final = slice > Equal
    result = slice.getSlice(a, b).lookLast(lookFor)
    if result.item?()
        then result:put(Pair(slice[0], UInt64).create(result[].first, result[].second + a.convertTo(UInt64)))

func lookLastFromAtoB(slice [_], a > BasicUnsignedInteger, b > BasicUnsignedInteger, lookFor slice) Box(UInt64)
    attributes
        alwaysInline
    rules
        final = slice > Equal
    result = slice.getSlice(a, b).lookLast(lookFor)
    if result.item?()
        then result:put(result[] + a.convertTo(UInt64))

func lookLastFromAtoB(slice [_], a > BasicUnsignedInteger, b > BasicUnsignedInteger, lookFor VAList(slice)) Box(Pair(slice, UInt64))
    attributes
        alwaysInline
    rules
        final = slice > Equal
    result = slice.getSlice(a, b).lookLast(lookFor)
    if result.item?()
        then result:put(Pair(slice, UInt64).create(result[].first, result[].second + a.convertTo(UInt64)))

func lookLastN(slice [_], n > BasicUnsignedInteger, lookFor slice[0]) Box(UInt64)
    attributes
        alwaysInline
    rules
        final = slice > Equal
    flag debug is set?
        then debugMessage(n == #n, "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - \042N\042 is zero.")
    mutN := n
    for index := slice.getLength() - 1; index != UInt64.maxValue(); index--
        if slice[index] == lookFor
            then if mutN == 1.convertTo(#n)
                then
                    result:put(index)
                    break
                else mutN--

func lookLastN(slice [_], n > BasicUnsignedInteger, lookFor VAList(slice[0])) Box(Pair(slice[0], UInt64))
    attributes
        alwaysInline
    rules
        final = slice > Equal
    flag debug is set?
        then
            debugMessage(lookFor.getLength() == UInt8, "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - there is nothing to look for.")
            debugMessage(n == #n, "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - \042N\042 is zero.")
    mutN := n
    for sliceIndex := slice.getLength() - 1; sliceIndex != UInt64.maxValue(); sliceIndex--
        parse _, lookForItem <- lookFor
            if slice[sliceIndex] == lookForItem
                then if mutN == 1.convertTo(#n)
                    then
                        result:put(Pair(slice[0], UInt64).create(lookForItem, sliceIndex))
                        return
                    else
                        mutN--
                        break

func lookLastN(slice [_], n > BasicUnsignedInteger, lookFor slice) Box(UInt64)
    attributes
        alwaysInline
    rules
        final = slice > Equal
    flag debug is set?
        then
            debugMessage(lookFor.getLength() == 0, "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - there is nothing to look for.")
            debugMessage(n == #n, "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - \042N\042 is zero.")
    sliceContainFirstChar := slice
    sliceContainLookFor := slice
    mutN := n
    firstItem .= lookFor[0]
    for sliceContainLookFor.getLength() >= lookFor.getLength()
        lastItemIndex .= sliceContainFirstChar.lookLast(firstItem)
        if lastItemIndex.empty?()
            then break
        if sliceContainLookFor.getAllExceptFirstN(lastItemIndex[]).hasPrefix?(lookFor)
            then if mutN == 1.convertTo(#n)
                then
                    result:put(lastItemIndex[])
                    break
                else
                    sliceContainLookFor = sliceContainLookFor.getFirstN(lastItemIndex[])
                    mutN--
        sliceContainFirstChar = sliceContainFirstChar.getFirstN(lastItemIndex[])

func lookLastN(slice [_], n > BasicUnsignedInteger, lookFor VAList(slice)) Box(Pair(slice, UInt64))
    attributes
        alwaysInline
    rules
        final = slice > Equal
    flag debug is set?
        then
            debugMessage(lookFor.getLength() == UInt8, "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - there is nothing to look for.")
            debugMessage(n == #n, "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - \042N\042 is zero.")
    firstsItems := VAList(slice[0])
    enslave(firstsItems)
    listLength .= lookFor.getLength()
    C
        firstsItems_.length = listLength_;
    minLength := UInt64.maxValue()
    parse index, item <- lookFor
        flag debug is set?
            then debugMessage(item.getLength() == 0, "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - there is nothing to count.")
        minLength = minLength.min(item.getLength())
        C
            firstsItems_.items[index_] = item_.items[0];
    sliceContainFirstChar := slice
    sliceContainLookFor := slice
    mutN := n
    for sliceContainLookFor.getLength() >= minLength
        lastItemAndIndex .= sliceContainFirstChar.lookLast(firstsItems)
        if lastItemAndIndex.empty?()
            then break
        lastPart .= sliceContainLookFor.getAllExceptFirstN(lastItemAndIndex[].second)
        parse _, item <- lookFor
            if lastPart.hasPrefix?(item)
                then if mutN == 1.convertTo(#n)
                    then
                        result:put(Pair(slice, UInt64).create(item, lastItemAndIndex[].second))
                        return
                    else
                        sliceContainLookFor = sliceContainLookFor.getFirstN(lastItemAndIndex[].second)
                        mutN--
                        break
        sliceContainFirstChar = sliceContainFirstChar.getFirstN(lastItemAndIndex[].second)

func lookLastNFromAtoB(slice [_], n > BasicUnsignedInteger, a > BasicUnsignedInteger, b > BasicUnsignedInteger, lookFor slice[0]) Box(UInt64)
    attributes
        alwaysInline
    rules
        final = slice > Equal
    result = slice.getSlice(a, b).lookLastN(n, lookFor)
    if result.item?()
        then result:put(result[] + a.convertTo(UInt64))

func lookLastNFromAtoB(slice [_], n > BasicUnsignedInteger, a > BasicUnsignedInteger, b > BasicUnsignedInteger, lookFor VAList(slice[0])) Box(Pair(slice[0], UInt64))
    attributes
        alwaysInline
    rules
        final = slice > Equal
    result = slice.getSlice(a, b).lookLastN(n, lookFor)
    if result.item?()
        then result:put(Pair(slice[0], UInt64).create(result[].first, result[].second + a.convertTo(UInt64)))

func lookLastNFromAtoB(slice [_], n > BasicUnsignedInteger, a > BasicUnsignedInteger, b > BasicUnsignedInteger, lookFor slice) Box(UInt64)
    attributes
        alwaysInline
    rules
        final = slice > Equal
    result = slice.getSlice(a, b).lookLastN(n, lookFor)
    if result.item?()
        then result:put(result[] + a.convertTo(UInt64))

func lookLastNFromAtoB(slice [_], n > BasicUnsignedInteger, a > BasicUnsignedInteger, b > BasicUnsignedInteger, lookFor VAList(slice)) Box(Pair(slice, UInt64))
    attributes
        alwaysInline
    rules
        final = slice > Equal
    result = slice.getSlice(a, b).lookLastN(n, lookFor)
    if result.item?()
        then result:put(Pair(slice, UInt64).create(result[].first, result[].second + a.convertTo(UInt64)))

func lookN(slice [_], n > BasicUnsignedInteger, lookFor slice[0]) Box(UInt64)
    attributes
        alwaysInline
    rules
        final = slice > Equal
    flag debug is set?
        then debugMessage(n == #n, "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - \042N\042 is zero.")
    mutN := n
    parse index, item <- slice
        if item == lookFor
            then if mutN == 1.convertTo(#n)
                then
                    result:put(index)
                    break
                else mutN--

func lookN(slice [_], n > BasicUnsignedInteger, lookFor VAList(slice[0])) Box(Pair(slice[0], UInt64))
    attributes
        alwaysInline
    rules
        final = slice > Equal
    flag debug is set?
        then
            debugMessage(lookFor.getLength() == UInt8, "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - there is nothing to look for.")
            debugMessage(n == #n, "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - \042N\042 is zero.")
    mutN := n
    parse sliceIndex, sliceItem <- slice
        parse _, lookForItem <- lookFor
            if sliceItem == lookForItem
                then if mutN == 1.convertTo(#n)
                    then
                        result:put(Pair(slice[0], UInt64).create(lookForItem, sliceIndex))
                        return
                    else
                        mutN--
                        break

func lookN(slice [_], n > BasicUnsignedInteger, lookFor slice) Box(UInt64)
    attributes
        alwaysInline
    rules
        final = slice > Equal
    flag debug is set?
        then
            debugMessage(lookFor.getLength() == 0, "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - there is nothing to look for.")
            debugMessage(n == #n, "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - \042N\042 is zero.")
    mutSlice := slice
    mutN := n
    firstItem .= lookFor[0]
    resultIndex := 0
    for mutSlice.getLength() >= lookFor.getLength()
        firstItemIndex .= mutSlice.look(firstItem)
        if firstItemIndex.empty?()
            then break
        resultIndex += firstItemIndex[]
        mutSlice = mutSlice.getAllExceptFirstN(firstItemIndex[])
        addToResultItem := 1
        if mutSlice.hasPrefix?(lookFor)
            then if mutN == 1.convertTo(#n)
                then
                    result:put(resultIndex)
                    break
                else
                    addToResultItem = lookFor.getLength()
                    mutN--
        mutSlice = mutSlice.getAllExceptFirstN(addToResultItem)
        resultIndex += addToResultItem

func lookN(slice [_], n > BasicUnsignedInteger, lookFor VAList(slice)) Box(Pair(slice, UInt64))
    attributes
        alwaysInline
    rules
        final = slice > Equal
    flag debug is set?
        then
            debugMessage(lookFor.getLength() == UInt8, "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - there is nothing to look for.")
            debugMessage(n == #n, "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - \042N\042 is zero.")
    mutSlice := slice
    firstsItems := VAList(slice[0])
    enslave(firstsItems)
    listLength .= lookFor.getLength()
    C
        firstsItems_.length = listLength_;
    minLength := UInt64.maxValue()
    parse index, item <- lookFor
        flag debug is set?
            then debugMessage(item.getLength() == 0, "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - there is nothing to count.")
        minLength = minLength.min(item.getLength())
        C
            firstsItems_.items[index_] = item_.items[0];
    mutN := n
    resultIndex := 0
    for mutSlice.getLength() >= minLength
        firstItemAndIndex .= mutSlice.look(firstsItems)
        if firstItemAndIndex.empty?()
            then break
        resultIndex += firstItemAndIndex[].second
        mutSlice = mutSlice.getAllExceptFirstN(firstItemAndIndex[].second)
        addToResultItem := 1
        parse _, item <- lookFor
            if mutSlice.hasPrefix?(item)
                then if mutN == 1.convertTo(#n)
                    then
                        result:put(Pair(slice, UInt64).create(item, resultIndex))
                        return
                    else
                        mutN--
                        addToResultItem = item.getLength()
                        break
        resultIndex += addToResultItem
        mutSlice = mutSlice.getAllExceptFirstN(addToResultItem)

func lookNFromAtoB(slice [_], n > BasicUnsignedInteger, a > BasicUnsignedInteger, b > BasicUnsignedInteger, lookFor slice[0]) Box(UInt64)
    attributes
        alwaysInline
    rules
        final = slice > Equal
    result = slice.getSlice(a, b).lookN(n, lookFor)
    if result.item?()
        then result:put(result[] + a.convertTo(UInt64))

func lookNFromAtoB(slice [_], n > BasicUnsignedInteger, a > BasicUnsignedInteger, b > BasicUnsignedInteger, lookFor VAList(slice[0])) Box(Pair(slice[0], UInt64))
    attributes
        alwaysInline
    rules
        final = slice > Equal
    result = slice.getSlice(a, b).lookN(n, lookFor)
    if result.item?()
        then result:put(Pair(slice[0], UInt64).create(result[].first, result[].second + a.convertTo(UInt64)))

func lookNFromAtoB(slice [_], n > BasicUnsignedInteger, a > BasicUnsignedInteger, b > BasicUnsignedInteger, lookFor slice) Box(UInt64)
    attributes
        alwaysInline
    rules
        final = slice > Equal
    result = slice.getSlice(a, b).lookN(n, lookFor)
    if result.item?()
        then result:put(result[] + a.convertTo(UInt64))

func lookNFromAtoB(slice [_], n > BasicUnsignedInteger, a > BasicUnsignedInteger, b > BasicUnsignedInteger, lookFor VAList(slice)) Box(Pair(slice, UInt64))
    attributes
        alwaysInline
    rules
        final = slice > Equal
    result = slice.getSlice(a, b).lookN(n, lookFor)
    if result.item?()
        then result:put(Pair(slice, UInt64).create(result[].first, result[].second + a.convertTo(UInt64)))

func not(slice [_]) slice
    attributes
        alwaysInline
    rules
        final = slice > Bits
    result = #slice.init(slice.getLength())
    parse index, item <- slice
        result:setItem(index, item.not())
    if slice.string?()
        then result:setStringFlag()

func or(slice1 [_], slice2 slice1) slice1
    attributes
        alwaysInline
    rules
        final = slice1 > Bits
    flag debug is set?
        then debugMessage(slice1.getLength() != slice2.getLength(), "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - the size of the first slice is different from the size of the second.")
    result = #slice1.init(slice1.getLength())
    parse index, item <- slice1
        result:setItem(index, item | slice2[index])
    if slice1.string?()
        then result:setStringFlag()

proc orEq(:slice1 [_], slice2 slice1)
    attributes
        alwaysInline
    rules
        final = slice1 > Bits
    flag debug is set?
        then debugMessage(slice1.getLength() != slice2.getLength(), "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - the size of the first slice is different from the size of the second.")
    parse index, item <- slice2
        slice1:setItem(index, slice1[index] | item)

func parse_first(slice [_]) UInt64
    attributes
        alwaysInline
    result = 0

func parse_haveItem?(slice [_], index UInt64) Bool
    attributes
        alwaysInline
    result = index < slice.getLength()

func parse_item(slice [_], index UInt64) slice[0]
    attributes
        alwaysInline
    result = slice[index]

func parse_key(slice [_], index UInt64) UInt64
    attributes
        alwaysInline
    result = index

func parse_next(slice [_], index UInt64) UInt64
    attributes
        alwaysInline
    result = index + 1

proc setStringFlag(:slice [_])
    attributes
        alwaysInline
    C
        slice_->isString = true;

func replace(slice [_], old slice[0], new old) slice
    attributes
        alwaysInline
    rules
        final = slice > Equal
    result = slice
    indexes .= slice.lookAll(old)
    parse _, index <- indexes
        result:setItem(index, new)

func replace(slice [_], old slice, new slice) slice
    attributes
        alwaysInline
    rules
        final = slice > Equal
    flag debug is set?
        then debugMessage(old.getLength() == 0, "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - there is nothing to replace.")
    if slice.getLength() != 0
        then
            parts .= slice.split(old)
            newSliceLength .= slice.getLength() - (old.getLength() - new.getLength()) * parts.getLength()
            result = #slice.dummy(newSliceLength)
            result += parts[0]
            parse _, part <- parts.getAllExceptFirst()
                result:join(new, part)
    if slice.string?()
        then result:setStringFlag()

proc setFirst(:slice [_], newItem slice[0])
    attributes
        alwaysInline
    slice:setItem(0, newItem)

proc setItem(:slice [_], index > BasicUnsignedInteger, newItem slice[0])
    attributes
        alwaysInline
    flag debug is set?
        then debugMessage(index.convertTo(UInt64) >= slice.getLength(), "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - the index is too large.")
    if slice.use?()
        then slice = slice.clone()
    oldItem := #slice[0]
    C
        oldItem_ = slice_->items[index_];
        slice_->items[index_] = newItem_;
    newItem.use()

proc setLast(:slice [_], newItem slice[0])
    attributes
        alwaysInline
    slice:setItem(slice.getLength() - 1, newItem)

func shl(slice [_], shifts > BasicUnsignedInteger) slice
    attributes
        alwaysInline
    rules
        final = slice > Bits
    result = #slice.init(slice.getLength())
    parse index, item <- slice
        result:setItem(index, item << shifts)
    if slice.string?()
        then result:setStringFlag()

proc shlEq(:slice [_], shifts > BasicUnsignedInteger)
    attributes
        alwaysInline
    rules
        final = slice > Bits
    for index := 0; index < slice.getLength(); index++
        slice:setItem(index, slice[index] << shifts)

func shr(slice [_], shifts > BasicUnsignedInteger) slice
    attributes
        alwaysInline
    rules
        final = slice > Bits
    result = #slice.init(slice.getLength())
    parse index, item <- slice
        result:setItem(index, item >> shifts)
    if slice.string?()
        then result:setStringFlag()

proc shrEq(:slice [_], shifts > BasicUnsignedInteger)
    attributes
        alwaysInline
    rules
        final = slice > Bits
    for index := 0; index < slice.getLength(); index++
        slice:setItem(index, slice[index] >> shifts)

func sort(slice [_], rise Bool) slice
    rules
        final = slice > Ordered
    result = slice
    result:sort(rise)

proc sort(:slice [_], rise Bool)
    rules
        final = slice > Ordered
    unsortedRanges := [Pair(UInt64, UInt64)].dummy(128)
    unsortedRanges += Pair(UInt64, UInt64).create(0, slice.getLength())
    leftIndex := 0
    rightEdge := 0
    for
        if leftIndex == rightEdge
            then if unsortedRanges.getLength() == 0
                then break
                else
                    range .= unsortedRanges.getLast()
                    unsortedRanges = unsortedRanges.getAllExceptLast()
                    leftIndex = range.first
                    rightEdge = range.second
        rangeLength .= rightEdge - leftIndex
        mif
            rangeLength > 2
                randomIndex .= getStaticRandomNumber() % rangeLength + leftIndex
                slice:swap(leftIndex, randomIndex)
                currentItem .= slice[leftIndex]
                swapLeftIndex := 0
                swapRightIndex := 0
                secondSwapIndexMaxValue := rightEdge - 1
                for swapLeftIndex = leftIndex + 1; swapLeftIndex <= secondSwapIndexMaxValue; swapLeftIndex++
                    if (rise && slice[swapLeftIndex] >= currentItem) || (!rise && slice[swapLeftIndex] <= currentItem)
                        then
                            for swapRightIndex = secondSwapIndexMaxValue; swapRightIndex > swapLeftIndex; swapRightIndex--
                                if (rise && slice[swapRightIndex] < currentItem) || (!rise && slice[swapRightIndex] > currentItem)
                                    then
                                        slice:swap(swapLeftIndex, swapRightIndex)
                                        secondSwapIndexMaxValue = swapRightIndex - 1
                                        break
                            if swapLeftIndex == swapRightIndex
                                then break
                newItemPosition .= swapLeftIndex - 1
                slice:swap(leftIndex, newItemPosition)
                leftRangeSize .= newItemPosition - leftIndex
                righRangeSize .= rightEdge - newItemPosition - 1
                if leftRangeSize > righRangeSize
                    then if righRangeSize == 0
                        then rightEdge = newItemPosition
                        else
                            unsortedRanges += Pair(UInt64, UInt64).create(leftIndex, newItemPosition)
                            leftIndex = newItemPosition + 1
                    else if leftRangeSize == 0
                        then leftIndex = newItemPosition + 1
                        else
                            unsortedRanges += Pair(UInt64, UInt64).create(newItemPosition + 1, rightEdge)
                            rightEdge = newItemPosition
            rangeLength == 2
                if (rise && slice[leftIndex] > slice[leftIndex + 1]) || (!rise && slice[leftIndex] < slice[leftIndex + 1])
                    then slice:swap(leftIndex, leftIndex + 1)
                fallthrough
            default
                if unsortedRanges.getLength() == 0
                    then break all
                    else leftIndex = rightEdge

func sort(slice [_], lessFunc @(slice[0], slice[0]) -> Bool) slice
    result = slice
    result:sort(lessFunc)

proc sort(:slice [_], lessFunc @(slice[0], slice[0]) -> Bool)
    unsortedRanges := [Pair(UInt64, UInt64)].dummy(128)
    unsortedRanges += Pair(UInt64, UInt64).create(0, slice.getLength())
    leftIndex := 0
    rightEdge := 0
    for
        if leftIndex == rightEdge
            then if unsortedRanges.getLength() == 0
                then break
                else
                    range .= unsortedRanges.getLast()
                    unsortedRanges = unsortedRanges.getAllExceptLast()
                    leftIndex = range.first
                    rightEdge = range.second
        rangeLength .= rightEdge - leftIndex
        mif
            rangeLength > 2
                randomIndex .= getStaticRandomNumber() % rangeLength + leftIndex
                slice:swap(leftIndex, randomIndex)
                currentItem .= slice[leftIndex]
                swapLeftIndex := 0
                swapRightIndex := 0
                secondSwapIndexMaxValue := rightEdge - 1
                for swapLeftIndex = leftIndex + 1; swapLeftIndex <= secondSwapIndexMaxValue; swapLeftIndex++
                    if !@lessFunc(slice[swapLeftIndex], currentItem)
                        then
                            for swapRightIndex = secondSwapIndexMaxValue; swapRightIndex > swapLeftIndex; swapRightIndex--
                                if @lessFunc(slice[swapRightIndex], currentItem)
                                    then
                                        slice:swap(swapLeftIndex, swapRightIndex)
                                        secondSwapIndexMaxValue = swapRightIndex - 1
                                        break
                            if swapLeftIndex == swapRightIndex
                                then break
                newItemPosition .= swapLeftIndex - 1
                slice:swap(leftIndex, newItemPosition)
                leftRangeSize .= newItemPosition - leftIndex
                righRangeSize .= rightEdge - newItemPosition - 1
                if leftRangeSize > righRangeSize
                    then if righRangeSize == 0
                        then rightEdge = newItemPosition
                        else
                            unsortedRanges += Pair(UInt64, UInt64).create(leftIndex, newItemPosition)
                            leftIndex = newItemPosition + 1
                    else if leftRangeSize == 0
                        then leftIndex = newItemPosition + 1
                        else
                            unsortedRanges += Pair(UInt64, UInt64).create(newItemPosition + 1, rightEdge)
                            rightEdge = newItemPosition
            rangeLength == 2
                if !@lessFunc(slice[leftIndex], slice[leftIndex + 1])
                    then slice:swap(leftIndex, leftIndex + 1)
                fallthrough
            default
                if unsortedRanges.getLength() == 0
                    then break all
                    else leftIndex = rightEdge

func split(slice [_], separator slice[0]) [slice]
    attributes
        alwaysInline
    rules
        final = slice > Equal
    if slice.getLength() == 0
        then result = [slice]{#slice}
        else
            allSeparatorsPositions .= slice.lookAll(separator)
            result = [slice].init(allSeparatorsPositions.getLength() + 1)
            previousPosition := 0
            parse index, separatorPosition <- allSeparatorsPositions
                result:setItem(index, slice.getSlice(previousPosition, separatorPosition))
                previousPosition = separatorPosition + 1
            result:setLast(slice.getAllExceptFirstN(previousPosition))

func split(slice [_], separators VAList(slice[0])) [slice]
    attributes
        alwaysInline
    rules
        final = slice > Equal
    allSeparatorsPositions .= slice.lookAll(separators)
    if slice.getLength() == 0
        then result = [slice]{#slice}
        else
            result = [slice].init(allSeparatorsPositions.getLength() + 1)
            previousPosition := 0
            parse index, separatorPosition <- allSeparatorsPositions
                result:setItem(index, slice.getSlice(previousPosition, separatorPosition.second))
                previousPosition = separatorPosition.second + 1
            result:setLast(slice.getAllExceptFirstN(previousPosition))

func split(slice [_], separator slice) [slice]
    attributes
        alwaysInline
    rules
        final = slice > Equal
    allSeparatorsPositions .= slice.lookAll(separator)
    if slice.getLength() == 0
        then result = [slice]{#slice}
        else
            result = [slice].init(allSeparatorsPositions.getLength() + 1)
            previousPosition := 0
            parse index, separatorPosition <- allSeparatorsPositions
                result:setItem(index, slice.getSlice(previousPosition, separatorPosition))
                previousPosition = separatorPosition + separator.getLength()
            result:setLast(slice.getAllExceptFirstN(previousPosition))

func split(slice [_], separators VAList(slice)) [slice]
    attributes
        alwaysInline
    rules
        final = slice > Equal
    allSeparatorsPositions .= slice.lookAll(separators)
    if slice.getLength() == 0
        then result = [slice]{#slice}
        else
            result = [slice].init(allSeparatorsPositions.getLength() + 1)
            previousPosition := 0
            parse index, separator <- allSeparatorsPositions
                result:setItem(index, slice.getSlice(previousPosition, separator.second))
                previousPosition = separator.second + separator.first.getLength()
            result:setLast(slice.getAllExceptFirstN(previousPosition))

func string?(slice [_]) Bool
    attributes
        alwaysInline
    if #slice[0].getTypeNumber() == UInt8.getTypeNumber()
        then
            C
                result_ = slice_.isString;

proc swap(:slice [_], first > BasicUnsignedInteger, second > BasicUnsignedInteger)
    attributes
        alwaysInline
    flag debug is set?
        then
            debugMessage(first.convertTo(UInt64) >= slice.getLength(), "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - first index is too large.")
            debugMessage(second.convertTo(UInt64) >= slice.getLength(), "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - second index is too large.")
    if slice.use?()
        then slice = slice.clone()
    tmp := #slice[0]
    enslave(tmp)
    C
        tmp_ = slice_->items[first_];
        slice_->items[first_] = slice_->items[second_];
        slice_->items[second_] = tmp_;

func toString(slice [UInt8]) [UInt8] #6
    result = select(slice.string?(), slice, builtInCallFunctionByID("to string function (standart module)", slice))

func toString(slice [_]) [UInt8]
    attributes
        id = "to string function (standart module)"
    rules
        final = slice > StringWriter
    result = "["
    if slice.getLength() != 0
        then
            parse _, item <- slice
                result:join(item.toString(), ", ")
            result = result.getAllExceptLastN(2)
    result += ']'

proc use(slice [_])
    attributes
        alwaysInline
    C
        if (slice_.useCounter != (uint64_t*){0}) {
            (*slice_.useCounter)++;
        }

func use?(slice [_]) Bool
    attributes
        alwaysInline
    C
        if (slice_.useCounter != (uint64_t*){0}) {
            result_ = *slice_.useCounter > 1;
        }
        result_ = result_ || ((void*)slice_.array == (void*){0} && (void*)slice_.items != (void*){0});

func xor(slice1 [_], slice2 slice1) slice1
    attributes
        alwaysInline
    rules
        final = slice1 > Bits
    flag debug is set?
        then debugMessage(slice1.getLength() != slice2.getLength(), "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - the size of the first slice is different from the size of the second.")
    result = #slice1.init(slice1.getLength())
    parse index, item <- slice1
        result:setItem(index, item ^ slice2[index])
    if slice1.string?()
        then result:setStringFlag()

proc xorEq(:slice1 [_], slice2 slice1)
    attributes
        alwaysInline
    rules
        final = slice1 > Bits
    flag debug is set?
        then debugMessage(slice1.getLength() != slice2.getLength(), "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - the size of the first slice is different from the size of the second.")
    parse index, item <- slice2
        slice1:setItem(index, slice1[index] ^ item)
