group BasicInteger
//require
//fromString(a, [UInt8]) -> a
//maxValue(a) -> a
//minValue(a) -> a
//power(a, a) -> a
//random(a) -> a
//shl(a, b) -> a
//shr(a, b) -> a
//toString(a) -> [UInt8]

rules
    1 = type > BasicInteger
    join 1 BasicNumber
    join 1 Integer
    join 1 Bits
    join 1 Limited
    join 1 Hashed
    join 1 Binary

func and(a > BasicInteger, b a) a #4
    attributes
        alwaysInline
    C
        result_ = a_ & b_;

func convertTo(from > BasicInteger, to) to #4
    attributes
        alwaysInline
    rules
        final = to > BasicInteger | to > BasicFloat
    C
        result_ = from_;

proc dec(:a > BasicInteger) #4
    attributes
        alwaysInline
    C
        (*a_)--;

func getHash(a > BasicInteger) UInt64 #4
    attributes
        alwaysInline
    C
        result_ = a_;

func getHashSize(a > BasicInteger) UInt8 #4
    attributes
        alwaysInline
    result = #a.getTypeSize().convertTo(UInt8)

proc inc(:a > BasicInteger) #4
    attributes
        alwaysInline
    C
        (*a_)++;

func mod(a > BasicInteger, b a) a #4
    attributes
        alwaysInline
    flag debug is set?
        then debugMessage(b == 0, "File: " builtIn_currentFile ", line: " builtIn_currentLine ". UB - division by zero.")
    C
        result_ = a_ % b_;

proc modEq(:a > BasicInteger, b a) #4
    attributes
        alwaysInline
    a = a % b

func not(a > BasicInteger) a #4
    attributes
        alwaysInline
    C
        result_ = ~a_;

func or(a > BasicInteger, b a) a #4
    attributes
        alwaysInline
    C
        result_ = a_ | b_;

func xor(a > BasicInteger, b a) a #4
    attributes
        alwaysInline
    C
        result_ = a_ ^ b_;
